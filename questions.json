{
  "type_01": [
  {
    "text": "Переведите число 11011₂ в десятичную систему.",
    "type": "choice",
    "options": ["27", "25", "29", "31"],
    "correct": "A",
    "comment": "Частая ошибка — неправильная степень двойки для старшего бита. Правильно: 1·2⁴ + 1·2³ + 0·2² + 1·2¹ + 1·2⁰ = 16+8+0+2+1=27."
  },
  {
    "text": "Переведите число 74₈ в двоичную систему.",
    "type": "choice",
    "options": ["111010₂", "111100₂", "111110₂", "111000₂"],
    "correct": "B",
    "comment": "Каждая восьмеричная цифра → 3 бита: 7→111, 4→100 → вместе: 111100. Ошибка: путать с шестнадцатеричным представлением."
  },
  {
    "text": "Переведите число A3₁₆ в восьмеричную систему.",
    "type": "choice",
    "options": ["253₈", "247₈", "243₈", "257₈"],
    "correct": "C",
    "comment": "A3₁₆ = 10100011₂ → группируем по 3: 010 100 011 → 2 4 3 → 243₈. Ошибка: забыть, что A=10, и вместо 1010 пишут 101 — тогда получают 253₈."
  },
  {
    "text": "Какое число в шестнадцатеричной системе соответствует 10110101₂?",
    "type": "choice",
    "options": ["A5₁₆", "C5₁₆", "D5₁₆", "B5₁₆"],
    "correct": "D",
    "comment": "Группируем по 4: 1011 0101 → B5. Ошибка: читать справа налево или перепутать порядок: 0101 1011 → 5B — такого варианта нет, но если бы был — его часто выбирают."
  },
  {
    "text": "Переведите число 37.5₁₀ в двоичную систему.",
    "type": "choice",
    "options": ["100101.1₂", "100111.1₂", "100101.01₂", "100111.01₂"],
    "correct": "A",
    "comment": "37 = 32+4+1 = 100101₂. 0.5 = 0.1₂. Итого: 100101.1₂. Ошибка: 0.5 → 0.01₂ (вместо 0.1) — получается 100101.01₂ — вариант C — частая ошибка."
  },
  {
    "text": "Переведите число 10101.011₂ в восьмеричную систему.",
    "type": "choice",
    "options": ["25.6₈", "25.3₈", "26.3₈", "26.6₈"],
    "correct": "B",
    "comment": "Целая часть: 010 101 = 2 5; дробная: 011 = 3 → 25.3₈. Ошибка: думать, что 011 = 6 — потому что путают с шестнадцатеричной. На самом деле 011₂ = 3₈."
  },
  {
    "text": "Переведите число F2.8₁₆ в десятичную систему.",
    "type": "choice",
    "options": ["242.25", "243.5", "242.5", "243.25"],
    "correct": "C",
    "comment": "F = 15 → 15×16 = 240, 2 = 2 → 242. 0.8₁₆ = 8/16 = 0.5. Итого: 242.5. Ошибка: 0.8 → 8/10 = 0.8 — получается 242.8 — такого варианта нет, но если бы был — его выбрали бы."
  },
  {
    "text": "Какое число в двоичной системе соответствует 27₈?",
    "type": "choice",
    "options": ["11011₂", "10011₂", "11101₂", "10111₂"],
    "correct": "D",
    "comment": "2 → 010, 7 → 111 → вместе: 010111 → убираем ведущий ноль → 10111. Ошибка: 27₈ = 27₁₀ — тогда получают 11011 — вариант B — частая ошибка."
  },
  {
    "text": "Переведите число 10110101.101₂ в шестнадцатеричную систему.",
    "type": "choice",
    "options": ["B5.A₁₆", "B5.C₁₆", "B5.5₁₆", "B5.D₁₆"],
    "correct": "A",
    "comment": "Группируем по 4: 1011 0101 . 1010 → B5.A. Ошибка: дробную часть 101 → 5 — тогда получается B5.5 — вариант B — частая ошибка из-за неполного заполнения до 4 бит."
  },
  {
    "text": "Переведите число 52.75₁₀ в двоичную систему.",
    "type": "choice",
    "options": ["110100.011₂", "110100.11₂", "110110.11₂", "110110.011₂"],
    "correct": "B",
    "comment": "52 = 32+16+4 = 110100₂. 0.75 = 0.5 + 0.25 = 0.11₂. Итого: 110100.11₂. Ошибка: 0.75 → 0.011₂ — получается 110100.011 — вариант B — частая ошибка при переводе дробной части."
  },
  {
    "text": "Переведите число 1110011₂ в восьмеричную систему.",
    "type": "choice",
    "options": ["153₈", "173₈", "163₈", "143₈"],
    "correct": "C",
    "comment": "Группируем: 001 110 011 → 1 6 3 → 163₈. Ошибка: начать группировку не с конца → 111 001 1 → 711."
  },
  {
    "text": "Переведите число C8₁₆ в десятичную систему.",
    "type": "choice",
    "options": ["198", "202", "204", "200"],
    "correct": "D",
    "comment": "C=12 → 12·16 + 8 = 192 + 8 = 200. Ошибка: C=13 (как D) → 13·16+8=216."
  },
  {
    "text": "Переведите число 10011100₂ в шестнадцатеричную систему.",
    "type": "choice",
    "options": ["9C₁₆", "8C₁₆", "9D₁₆", "8D₁₆"],
    "correct": "A",
    "comment": "1001 1100 → 9 C. Ошибка: перепутать 1100 (C=12) с D=13."
  },
  {
    "text": "Переведите число 25.25₁₀ в двоичную систему.",
    "type": "choice",
    "options": ["11011.01₂", "11001.01₂", "11011.1₂", "11001.1₂"],
    "correct": "B",
    "comment": "25=11001₂, 0.25=0.01₂. Ошибка: 0.25 → 0.1₂ (как 0.5)."
  },
  {
    "text": "Переведите число 1101.11₂ в восьмеричную систему.",
    "type": "choice",
    "options": ["15.3₈", "16.6₈", "15.6₈", "16.3₈"],
    "correct": "C",
    "comment": "Целая: 001 101 = 1 5; дробная: 110 → 6 → 15.6₈. Ошибка: не дополнить дробную часть до 3 бит."
  },
  {
    "text": "Переведите число B4.4₁₆ в двоичную систему.",
    "type": "choice",
    "options": ["10110100.1₂", "10110100.001₂", "10110100.11₂", "10110100.01₂"],
    "correct": "D",
    "comment": "B=1011, 4=0100, .4=0100 → но берём только значащие: .01. Ошибка: .4₁₆ = 4/16 = 0.25 = 0.01₂."
  },
  {
    "text": "Переведите число 63₈ в шестнадцатеричную систему.",
    "type": "choice",
    "options": ["33₁₆", "31₁₆", "35₁₆", "37₁₆"],
    "correct": "A",
    "comment": "63₈ = 110011₂ → 0011 0011 → 33₁₆. Ошибка: 63₈ = 6·8+3=51 → 51₁₀ = 33₁₆ — верно, но некоторые считают 63₁₀."
  },
  {
    "text": "Переведите число 10101010₂ в десятичную систему.",
    "type": "choice",
    "options": ["168", "170", "174", "172"],
    "correct": "B",
    "comment": "128+32+8+2=170. Ошибка: пропустить один из битов → 168 или 172."
  },
  {
    "text": "Переведите число 4A.8₁₆ в восьмеричную систему.",
    "type": "choice",
    "options": ["112.2₈", "110.4₈", "112.4₈", "110.2₈"],
    "correct": "C",
    "comment": "4A.8₁₆ = 01001010.1000₂ → группируем: 001 001 010 . 100 → 1 1 2 . 4 → 112.4₈. Ошибка: неверно сгруппировать дробную часть."
  },
  {
    "text": "Переведите число 0.625₁₀ в двоичную систему.",
    "type": "choice",
    "options": ["0.11₂", "0.011₂", "0.111₂", "0.101₂"],
    "correct": "D",
    "comment": "0.625 = 0.5 + 0.125 = 0.101₂. Ошибка: 0.625 → 0.11 (как 0.75)."
  },
  {
    "text": "Переведите число 11110000₂ в восьмеричную систему.",
    "type": "choice",
    "options": ["360₈", "350₈", "380₈", "340₈"],
    "correct": "A",
    "comment": "011 110 000 → 3 6 0 → 360₈. Ошибка: начать с левого края без выравнивания."
  },
  {
    "text": "Переведите число 200₁₀ в шестнадцатеричную систему.",
    "type": "choice",
    "options": ["D8₁₆", "C8₁₆", "D4₁₆", "C4₁₆"],
    "correct": "B",
    "comment": "200 ÷ 16 = 12 (C), остаток 8 → C8. Ошибка: перепутать C и D."
  },
  {
    "text": "Переведите число 77₈ в двоичную систему.",
    "type": "choice",
    "options": ["111110₂", "111101₂", "111111₂", "111100₂"],
    "correct": "C",
    "comment": "7→111, 7→111 → 111111. Ошибка: подумать, что 77₈ = 77₁₀ → 1001101₂."
  },
  {
    "text": "Переведите число 101111.01₂ в шестнадцатеричную систему.",
    "type": "choice",
    "options": ["2F.2₁₆", "2E.4₁₆", "2F.4₁₆", "2E.2₁₆"],
    "correct": "D",
    "comment": "Целая: 0010 1111 → 2F; дробная: 0100 → 4 → 2F.4. Ошибка: не дополнить дробную часть до 4 бит."
  },
  {
    "text": "Переведите число 15.125₁₀ в двоичную систему.",
    "type": "choice",
    "options": ["1111.01₂", "1111.1₂", "1111.001₂", "1111.101₂"],
    "correct": "A",
    "comment": "15=1111, 0.125=0.001. Ошибка: 0.125 → 0.01 (как 0.25)."
  },
  {
    "text": "Переведите число D0.2₁₆ в десятичную систему.",
    "type": "choice",
    "options": ["208.25", "209.125", "208.125", "209.25"],
    "correct": "B",
    "comment": "D=13 → 13·16=208; 0.2₁₆=2/16=0.125. Ошибка: 0.2 → 0.2₁₀."
  },
  {
    "text": "Переведите число 10000000₂ в восьмеричную систему.",
    "type": "choice",
    "options": ["100₈", "400₈", "200₈", "300₈"],
    "correct": "C",
    "comment": "010 000 000 → 2 0 0 → 200₈. Ошибка: считать как 128₁₀ → 200₈ — верно, но некоторые получают 100₈."
  },
  {
    "text": "Переведите число 3F₁₆ в десятичную систему.",
    "type": "choice",
    "options": ["61", "65", "67", "63"],
    "correct": "D",
    "comment": "3·16 + 15 = 48 + 15 = 63. Ошибка: F=14 → 62."
  },
  {
    "text": "Переведите число 11001.101₂ в восьмеричную систему.",
    "type": "choice",
    "options": ["31.6₈", "32.5₈", "31.5₈", "32.6₈"],
    "correct": "A",
    "comment": "Целая: 011 001 = 3 1; дробная: 101 = 5 → 31.5₈. Ошибка: думать, что 101=6."
  },
  {
    "text": "Переведите число 0.875₁₀ в двоичную систему.",
    "type": "choice",
    "options": ["0.11₂", "0.101₂", "0.1001₂", "0.111₂"],
    "correct": "B",
    "comment": "0.875 = 0.5+0.25+0.125 = 0.111₂. Ошибка: остановиться на двух битах → 0.11."
  },
  {
    "text": "Переведите число E7₁₆ в восьмеричную систему.",
    "type": "choice",
    "options": ["357₈", "367₈", "347₈", "337₈"],
    "correct": "C",
    "comment": "E7 = 11100111₂ → 011 100 111 → 3 4 7 → 347₈. Ошибка: неверно перевести E=14 → 1110."
  },
  {
    "text": "Переведите число 10110011₂ в десятичную систему.",
    "type": "choice",
    "options": ["177", "181", "179", "183"],
    "correct": "D",
    "comment": "128+32+16+2+1=179. Ошибка: пропустить 16 → 163."
  },
  {
    "text": "Переведите число 50.5₁₀ в шестнадцатеричную систему.",
    "type": "choice",
    "options": ["32.4₁₆", "34.8₁₆", "32.8₁₆", "34.4₁₆"],
    "correct": "A",
    "comment": "50=32₁₆, 0.5=8/16=0.8₁₆. Ошибка: 0.5 → 0.4₁₆ (как 0.25)."
  },
  {
    "text": "Переведите число 11111111₂ в восьмеричную систему.",
    "type": "choice",
    "options": ["367₈", "357₈", "377₈", "347₈"],
    "correct": "B",
    "comment": "011 111 111 → 3 7 7. Ошибка: начать группировку с левого края без нулей."
  },
  {
    "text": "Переведите число A0.1₁₆ в двоичную систему.",
    "type": "choice",
    "options": ["10100000.001₂", "10100000.01₂", "10100000.0001₂", "10100000.1₂"],
    "correct": "C",
    "comment": "A=1010, 0=0000, .1=0001. Ошибка: .1₁₆ = 1/16 = 0.0625 = 0.0001₂."
  },
  {
    "text": "Переведите число 123₈ в десятичную систему.",
    "type": "choice",
    "options": ["81", "85", "83", "87"],
    "correct": "D",
    "comment": "1·64 + 2·8 + 3 = 64+16+3=83. Ошибка: 2·8=18 → 85."
  },
  {
    "text": "Переведите число 10010110₂ в шестнадцатеричную систему.",
    "type": "choice",
    "options": ["86₁₆", "94₁₆", "96₁₆", "84₁₆"],
    "correct": "A",
    "comment": "1001 0110 → 9 6. Ошибка: 0110=5 → 95."
  },
  {
    "text": "Переведите число 0.375₁₀ в двоичную систему.",
    "type": "choice",
    "options": ["0.11₂", "0.101₂", "0.111₂", "0.011₂"],
    "correct": "B",
    "comment": "0.375 = 0.25+0.125 = 0.011₂. Ошибка: 0.375 → 0.11 (как 0.75)."
  },
  {
    "text": "Переведите число B8₁₆ в восьмеричную систему.",
    "type": "choice",
    "options": ["260₈", "250₈", "270₈", "280₈"],
    "correct": "C",
    "comment": "B8 = 10111000₂ → 010 111 000 → 2 7 0 → 270₈. Ошибка: неверно перевести B=11."
  },
  {
    "text": "Переведите число 101010.1010₂ в шестнадцатеричную систему.",
    "type": "choice",
    "options": ["2A.5₁₆", "2B.A₁₆", "2A.A₁₆", "2B.5₁₆"],
    "correct": "D",
    "comment": "Целая: 0010 1010 → 2A; дробная: 1010 → A. Ошибка: не дополнить дробную часть до 4 бит."
  },
  {
    "text": "Переведите число 255₁₀ в двоичную систему.",
    "type": "choice",
    "options": ["11111110₂", "11111101₂", "11111111₂", "11111100₂"],
    "correct": "A",
    "comment": "2⁸–1=255 → все биты 1. Ошибка: забыть последний бит → 254."
  },
  {
    "text": "Переведите число 70.25₁₀ в восьмеричную систему.",
    "type": "choice",
    "options": ["106.1₈", "107.2₈", "106.2₈", "107.1₈"],
    "correct": "B",
    "comment": "70÷8=8(ост.6), 8÷8=1(ост.0), 1÷8=0(ост.1) → 106₈; 0.25=0.2₈. Ошибка: 0.25 → 0.1₈."
  },
  {
    "text": "Переведите число 11100011₂ в шестнадцатеричную систему.",
    "type": "choice",
    "options": ["D3₁₆", "E1₁₆", "E3₁₆", "D1₁₆"],
    "correct": "C",
    "comment": "1110 0011 → E 3. Ошибка: 1110=E=14, но некоторые берут D=13."
  },
  {
    "text": "Переведите число 0.9375₁₀ в двоичную систему.",
    "type": "choice",
    "options": ["0.111₂", "0.1101₂", "0.1111₂", "0.1011₂"],
    "correct": "D",
    "comment": "0.9375 = 0.5+0.25+0.125+0.0625 = 0.1111₂. Ошибка: остановиться на трёх битах."
  },
  {
    "text": "Переведите число 10000001₂ в десятичную систему.",
    "type": "choice",
    "options": ["127", "128", "129", "130"],
    "correct": "A",
    "comment": "128 + 1 = 129. Ошибка: забыть младший бит → 128."
  },
  {
    "text": "Переведите число F0.8₁₆ в восьмеричную систему.",
    "type": "choice",
    "options": ["360.2₈", "370.4₈", "360.4₈", "370.2₈"],
    "correct": "B",
    "comment": "F0.8 = 11110000.1000₂ → 011 110 000 . 100 → 3 6 0 . 4 → 360.4₈. Ошибка: неверно сгруппировать."
  },
  {
    "text": "Переведите число 1011101.11₂ в шестнадцатеричную систему.",
    "type": "choice",
    "options": ["5D.E₁₆", "5E.C₁₆", "5D.C₁₆", "5E.E₁₆"],
    "correct": "C",
    "comment": "Целая: 0101 1101 → 5D; дробная: 1100 → C. Ошибка: не дополнить дробную часть до 4 бит."
  },
  {
    "text": "Переведите число 100.1₂ в десятичную систему.",
    "type": "choice",
    "options": ["4.25", "5.5", "4.5", "5.25"],
    "correct": "D",
    "comment": "4 + 0.5 = 4.5. Ошибка: 0.1₂ = 0.1₁₀."
  },
  {
    "text": "Переведите число 64₈ в шестнадцатеричную систему.",
    "type": "choice",
    "options": ["32₁₆", "36₁₆", "34₁₆", "38₁₆"],
    "correct": "A",
    "comment": "64₈ = 110100₂ → 0011 0100 → 34₁₆. Ошибка: 64₈ = 6·8+4=52 → 34₁₆ — верно, но иногда путают с 64₁₀."
  },
  {
    "text": "Переведите число 0.1111₂ в десятичную систему.",
    "type": "choice",
    "options": ["0.875", "0.95", "0.9375", "0.9"],
    "correct": "B",
    "comment": "0.5+0.25+0.125+0.0625=0.9375. Ошибка: пропустить последний бит → 0.875."
  }
],

  "type_02": [
  {
    "text": "Выполните сложение беззнаковых 8-битных чисел: 11010110₂ + 00111011₂. Укажите результат в шестнадцатеричной системе.",
    "type": "choice",
    "options": ["107₁₆", "10B₁₆", "07₁₆", "0B₁₆"],
    "correct": "D",
    "comment": "Сумма = 214 + 59 = 273 → в 8 битах: 273 – 256 = 17 = 00010001₂ = 11₁₆ = 0B₁₆. Ошибка: не учесть переполнение → выбрать 10B₁₆."
  },
  {
    "text": "Выполните вычитание: 10110101₂ – 01000111₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["74", "76", "78", "80"],
    "correct": "C",
    "comment": "181 – 103 = 78. Ошибка: неверно перевести вычитаемое как 105 → получить 76."
  },
  {
    "text": "Чему равна сумма 11111111₂ + 00000001₂ в беззнаковой 8-битной арифметике? Результат в десятичной системе.",
    "type": "choice",
    "options": ["0", "1", "255", "256"],
    "correct": "A",
    "comment": "255 + 1 = 256 → в 8 битах: 00000000 → 0. Ошибка: игнорировать переполнение → выбрать 256."
  },
  {
    "text": "Выполните сложение беззнаковых чисел: A3₁₆ + 5C₁₆. Результат в шестнадцатеричной системе.",
    "type": "choice",
    "options": ["FF₁₆", "100₁₆", "EF₁₆", "F0₁₆"],
    "correct": "A",
    "comment": "A3=163, 5C=92 → 163+92=255=FF₁₆. Ошибка: сложить цифры по отдельности без переноса → получить EF."
  },
  {
    "text": "Выполните вычитание: 10010010₂ – 01101101₂. Результат в двоичной системе.",
    "type": "choice",
    "options": ["00100101₂", "00101001₂", "00110101₂", "00111001₂"],
    "correct": "A",
    "comment": "146 – 109 = 37 = 00100101₂. Ошибка: неверно занять разряд → получить 00101001."
  },
  {
    "text": "Сложите два знаковых 8-битных числа: 11100000₂ + 11110000₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["–48", "–46", "–44", "–42"],
    "correct": "A",
    "comment": "11100000 = –32, 11110000 = –16 → –32 + (–16) = –48. Ошибка: принять числа как беззнаковые → получить 224+240=464."
  },
  {
    "text": "Выполните сложение: 77₈ + 65₈. Результат в восьмеричной системе.",
    "type": "choice",
    "options": ["144₈", "154₈", "164₈", "174₈"],
    "correct": "C",
    "comment": "77₈=63, 65₈=53 → 63+53=116 → 116÷8=14(ост.4), 14÷8=1(ост.6), 1÷8=0(ост.1) → 164₈. Ошибка: складывать цифры без переноса → 142₈."
  },
  {
    "text": "Выполните вычитание: 10101010₂ – 01010101₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["83", "85", "87", "89"],
    "correct": "B",
    "comment": "170 – 85 = 85. Ошибка: перепутать вычитаемое с уменьшаемым → получить отрицательное число."
  },
  {
    "text": "Сложите беззнаковые 8-битные числа: 11110000₂ + 00010000₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["256", "0", "16", "240"],
    "correct": "B",
    "comment": "240 + 16 = 256 → в 8 битах: 0. Ошибка: не учесть переполнение → выбрать 256."
  },
  {
    "text": "Выполните сложение: B2₁₆ + 4E₁₆. Результат в шестнадцатеричной системе.",
    "type": "choice",
    "options": ["100₁₆", "FF₁₆", "FE₁₆", "FD₁₆"],
    "correct": "A",
    "comment": "B2=178, 4E=78 → 178+78=256=100₁₆. Ошибка: остановиться на FF из-за переполнения."
  },
  {
    "text": "Выполните вычитание: 11000000₂ – 00110000₂. Результат в двоичной системе.",
    "type": "choice",
    "options": ["10010000₂", "10100000₂", "10110000₂", "11000000₂"],
    "correct": "A",
    "comment": "192 – 48 = 144 = 10010000₂. Ошибка: подумать, что 192–48=192 → 11000000."
  },
  {
    "text": "Сложите знаковые 8-битные числа: 10000000₂ + 01111111₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["–1", "0", "1", "127"],
    "correct": "A",
    "comment": "10000000 = –128, 01111111 = +127 → –128 + 127 = –1. Ошибка: принять первое число как 128 → получить 255."
  },
  {
    "text": "Выполните сложение: 55₈ + 47₈. Результат в восьмеричной системе.",
    "type": "choice",
    "options": ["104₈", "114₈", "124₈", "134₈"],
    "correct": "C",
    "comment": "55₈=45, 47₈=39 → 45+39=84 → 84=124₈. Ошибка: 7+5=12 → записать 2, забыть перенос → 114₈."
  },
  {
    "text": "Выполните вычитание: 11111111₂ – 00001111₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["238", "240", "242", "244"],
    "correct": "B",
    "comment": "255 – 15 = 240. Ошибка: вычесть как 255–16=239."
  },
  {
    "text": "Сложите беззнаковые числа: FF₁₆ + 01₁₆. Результат в шестнадцатеричной системе в 8 битах.",
    "type": "choice",
    "options": ["00₁₆", "01₁₆", "100₁₆", "FF₁₆"],
    "correct": "A",
    "comment": "255 + 1 = 256 → в 8 битах: 00₁₆. Ошибка: выбрать 100₁₆, игнорируя ограничение разрядности."
  },
  {
    "text": "Выполните сложение: 10101010₂ + 01010101₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["253", "254", "255", "256"],
    "correct": "C",
    "comment": "170 + 85 = 255. Ошибка: добавить лишний перенос → 256."
  },
  {
    "text": "Выполните вычитание: 10000000₂ – 00000001₂ (беззнаковое). Результат в двоичной системе.",
    "type": "choice",
    "options": ["01111111₂", "10000001₂", "11111111₂", "00000001₂"],
    "correct": "A",
    "comment": "128 – 1 = 127 = 01111111₂. Ошибка: подумать, что 128–1=129 → 10000001."
  },
  {
    "text": "Сложите знаковые 8-битные числа: 11111111₂ + 00000001₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["0", "1", "–1", "–2"],
    "correct": "A",
    "comment": "11111111 = –1, 00000001 = +1 → –1 + 1 = 0. Ошибка: принять как беззнаковые → 255+1=256."
  },
  {
    "text": "Выполните сложение: 37₈ + 45₈. Результат в восьмеричной системе.",
    "type": "choice",
    "options": ["74₈", "82₈", "84₈", "104₈"],
    "correct": "D",
    "comment": "37₈=31, 45₈=37 → 31+37=68 → 68=104₈. Ошибка: 7+5=12 → записать 2, забыть перенос → 72₈."
  },
  {
    "text": "Выполните вычитание: A0₁₆ – 3F₁₆. Результат в десятичной системе.",
    "type": "choice",
    "options": ["95", "97", "99", "101"],
    "correct": "B",
    "comment": "A0=160, 3F=63 → 160–63=97. Ошибка: 3F=64 → 160–64=96."
  },
  {
    "text": "Сложите беззнаковые 8-битные числа: 10101010₂ + 10101010₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["340", "84", "85", "86"],
    "correct": "B",
    "comment": "170 + 170 = 340 → в 8 битах: 340 – 256 = 84. Ошибка: выбрать 340, игнорируя переполнение."
  },
  {
    "text": "Выполните сложение: 11110000₂ + 00001111₂. Результат в двоичной системе.",
    "type": "choice",
    "options": ["11111111₂", "00000000₂", "11110000₂", "00001111₂"],
    "correct": "A",
    "comment": "240 + 15 = 255 = 11111111₂. Ошибка: подумать, что это XOR → тоже 11111111, но в других случаях различается."
  },
  {
    "text": "Выполните вычитание: 100000000₂ – 00001010₂ (9-битное). Результат в десятичной системе.",
    "type": "choice",
    "options": ["244", "246", "248", "250"],
    "correct": "B",
    "comment": "256 – 10 = 246. Ошибка: считать как 8-битное → 0 – 10 → неверно."
  },
  {
    "text": "Сложите знаковые 8-битные числа: 11000000₂ + 11000000₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["–128", "–126", "–124", "–122"],
    "correct": "A",
    "comment": "11000000 = –64 → –64 + (–64) = –128. Ошибка: принять как беззнаковые → 192+192=384."
  },
  {
    "text": "Выполните сложение: 777₈ + 001₈. Результат в восьмеричной системе.",
    "type": "choice",
    "options": ["778₈", "1000₈", "770₈", "000₈"],
    "correct": "B",
    "comment": "777₈=511, +1=512=1000₈. Ошибка: написать 778₈ (но 8 недопустима в восьмеричной)."
  },
  {
    "text": "Выполните вычитание: 11111111₂ – 11111110₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["0", "1", "2", "3"],
    "correct": "B",
    "comment": "255 – 254 = 1. Ошибка: перепутать порядок → –1."
  },
  {
    "text": "Сложите беззнаковые числа: C0₁₆ + 40₁₆. Результат в шестнадцатеричной системе.",
    "type": "choice",
    "options": ["100₁₆", "00₁₆", "FF₁₆", "FE₁₆"],
    "correct": "B",
    "comment": "C0=192, 40=64 → 192+64=256 → в 8 битах: 00₁₆. Ошибка: выбрать 100₁₆."
  },
  {
    "text": "Выполните сложение: 10111111₂ + 00000001₂. Результат в десятичной системе (беззнаковое).",
    "type": "choice",
    "options": ["191", "192", "193", "194"],
    "correct": "B",
    "comment": "191 + 1 = 192. Ошибка: подумать, что 10111111=192 → 193."
  },
  {
    "text": "Выполните вычитание: 10000000₂ – 10000000₂. Результат в двоичной системе.",
    "type": "choice",
    "options": ["00000000₂", "11111111₂", "00000001₂", "10000000₂"],
    "correct": "A",
    "comment": "Любое число минус оно же = 0. Ошибка: применить побитовое NOT → 11111111."
  },
  {
    "text": "Сложите знаковые 8-битные числа: 01111111₂ + 00000001₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["128", "–128", "127", "–127"],
    "correct": "B",
    "comment": "127 + 1 = 128 → в знаковом 8-битном: 10000000 = –128 (переполнение). Ошибка: выбрать 128, игнорируя знаковость."
  },
  {
    "text": "Выполните сложение: 25₈ + 52₈. Результат в восьмеричной системе.",
    "type": "choice",
    "options": ["77₈", "100₈", "101₈", "102₈"],
    "correct": "A",
    "comment": "25₈=21, 52₈=42 → 21+42=63=77₈. Ошибка: 5+2=7, 2+5=7 → 77 — верно, но иногда путают порядок."
  },
  {
    "text": "Выполните вычитание: B0₁₆ – 70₁₆. Результат в десятичной системе.",
    "type": "choice",
    "options": ["62", "64", "66", "68"],
    "correct": "B",
    "comment": "B0=176, 70=112 → 176–112=64. Ошибка: B=11 → 110–70=40."
  },
  {
    "text": "Сложите беззнаковые 8-битные числа: 11111110₂ + 00000010₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["256", "0", "2", "254"],
    "correct": "B",
    "comment": "254 + 2 = 256 → в 8 битах: 0. Ошибка: выбрать 256."
  },
  {
    "text": "Выполните сложение: 01010101₂ + 10101010₂. Результат в двоичной системе.",
    "type": "choice",
    "options": ["11111111₂", "00000000₂", "11111110₂", "00000001₂"],
    "correct": "A",
    "comment": "85 + 170 = 255 = 11111111₂. Ошибка: подумать, что это XOR → тоже 11111111, но в других случаях различается."
  },
  {
    "text": "Выполните вычитание: 100000000₂ – 00000001₂. Результат в двоичной системе.",
    "type": "choice",
    "options": ["11111111₂", "011111111₂", "100000001₂", "000000001₂"],
    "correct": "B",
    "comment": "256 – 1 = 255 = 011111111₂ в 9 битах. Ошибка: выбрать 8-битный вариант 11111111."
  },
  {
    "text": "Сложите знаковые 8-битные числа: 10101010₂ + 01010101₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["–1", "0", "1", "2"],
    "correct": "A",
    "comment": "10101010 = –86, 01010101 = +85 → –86 + 85 = –1. Ошибка: принять оба как положительные → 171."
  },
  {
    "text": "Выполните сложение: 50₈ + 30₈. Результат в восьмеричной системе.",
    "type": "choice",
    "options": ["100₈", "110₈", "120₈", "130₈"],
    "correct": "A",
    "comment": "50₈=40, 30₈=24 → 40+24=64=100₈. Ошибка: складывать 5+3=8 → записать 0 с переносом → верно, но иногда забывают."
  },
  {
    "text": "Выполните вычитание: 11110000₂ – 00001111₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["223", "225", "227", "229"],
    "correct": "B",
    "comment": "240 – 15 = 225. Ошибка: 00001111=16 → 240–16=224."
  },
  {
    "text": "Сложите беззнаковые числа: 80₁₆ + 80₁₆. Результат в шестнадцатеричной системе (8-битный).",
    "type": "choice",
    "options": ["100₁₆", "00₁₆", "FF₁₆", "FE₁₆"],
    "correct": "B",
    "comment": "128 + 128 = 256 → в 8 битах: 00₁₆. Ошибка: выбрать 100₁₆."
  },
  {
    "text": "Выполните сложение: 01111111₂ + 01111111₂. Результат в десятичной системе (беззнаковое).",
    "type": "choice",
    "options": ["254", "255", "256", "127"],
    "correct": "A",
    "comment": "127 + 127 = 254. Ошибка: добавить 1 → 255."
  },
  {
    "text": "Выполните вычитание: 100000000₂ – 00000010₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["252", "254", "256", "258"],
    "correct": "B",
    "comment": "256 – 2 = 254. Ошибка: считать как 8-битное → 0 – 2."
  },
  {
    "text": "Сложите знаковые 8-битные числа: 11111110₂ + 11111110₂. Результат в десятичной системе.",
    "type": "choice",
    "options": ["–4", "–2", "0", "2"],
    "correct": "A",
    "comment": "11111110 = –2 → –2 + (–2) = –4. Ошибка: принять как беззнаковые → 254+254=508."
  },
  {
    "text": "Выполните сложение: 17₈ + 61₈. Результат в восьмеричной системе.",
    "type": "choice",
    "options": ["70₈", "76₈", "80₈", "100₈"],
    "correct": "D",
    "comment": "17₈=15, 61₈=49 → 15+49=64=100₈. Ошибка: 7+1=8 → записать 0, перенос → 80₈."
  },
  {
    "text": "Выполните вычитание: C8₁₆ – 40₁₆. Результат в десятичной системе.",
    "type": "choice",
    "options": ["134", "136", "138", "140"],
    "correct": "B",
    "comment": "C8=200, 40=64 → 200–64=136. Ошибка: C=13 → 138–64=74."
  },
  {
    "text": "Сложите беззнаковые 8-битные числа: 11111111₂ + 00000001₂. Результат в двоичной системе.",
    "type": "choice",
    "options": ["100000000₂", "00000000₂", "11111111₂", "00000001₂"],
    "correct": "B",
    "comment": "255 + 1 = 256 → в 8 битах: 00000000₂. Ошибка: выбрать 9-битный результат."
  },
  {
    "text": "Выполните сложение: 10101010₂ + 01010101₂. Результат в шестнадцатеричной системе.",
    "type": "choice",
    "options": ["AA₁₆", "55₁₆", "FF₁₆", "00₁₆"],
    "correct": "C",
    "comment": "170 + 85 = 255 = FF₁₆. Ошибка: подумать, что это конкатенация → AB или что-то подобное."
  },
  {
    "text": "Выполните вычитание: 00000000₂ – 01111111₂ (знаковое). Результат в десятичной системе.",
    "type": "choice",
    "options": ["–127", "–128", "127", "128"],
    "correct": "A",
    "comment": "0 – 127 = –127. Ошибка: выбрать –128."
  },
  {
    "text": "Выполните сложение: A0₁₆ + 60₁₆. Результат в шестнадцатеричной системе (8-битный).",
    "type": "choice",
    "options": ["100₁₆", "00₁₆", "FF₁₆", "FE₁₆"],
    "correct": "B",
    "comment": "A0=160, 60=96 → 160+96=256 → в 8 битах: 00₁₆. Ошибка: выбрать 100₁₆."
  },
  {
    "text": "Выполните сложение: 11111111₂ + 11111111₂. Результат в десятичной системе (беззнаковое, 8-битный).",
    "type": "choice",
    "options": ["510", "254", "255", "0"],
    "correct": "B",
    "comment": "255 + 255 = 510 → 510 – 256 = 254. Ошибка: выбрать 510."
  },
  {
    "text": "Выполните вычитание: 100000000₂ – 00000001₂. Результат в шестнадцатеричной системе.",
    "type": "choice",
    "options": ["FF₁₆", "100₁₆", "FE₁₆", "00₁₆"],
    "correct": "A",
    "comment": "256 – 1 = 255 = FF₁₆. Ошибка: выбрать 100₁₆."
  }
],

  "type_03": [
  {
    "text": "Чему равно значение выражения (-5) & 13 в 32-битной системе?",
    "type": "choice",
    "options": ["5", "11", "13", "9"],
    "correct": "D",
    "comment": "–5 = ...11111011, 13 = ...00001101 → AND = ...00001001 = 9."
  },
  {
    "text": "Чему равно значение выражения (-8) | 7 в 32-битной системе?",
    "type": "choice",
    "options": ["0", "15", "–8", "–1"],
    "correct": "D",
    "comment": "–8 = ...11111000, 7 = ...00000111 → OR = ...11111111 = –1."
  },
  {
    "text": "Чему равно значение выражения (-1) ^ 15 в 32-битной системе?",
    "type": "choice",
    "options": ["14", "–16", "16", "–14"],
    "correct": "B",
    "comment": "–1 = ...11111111, 15 = ...00001111 → XOR = ...11110000 = –16."
  },
  {
    "text": "Чему равно значение выражения ~10 в 32-битной системе?",
    "type": "choice",
    "options": ["–10", "11", "4294967285", "–11"],
    "correct": "D",
    "comment": "~x = –x–1 → ~10 = –11."
  },
  {
    "text": "Чему равно значение выражения (-8) & 12 в 32-битной системе?",
    "type": "choice",
    "options": ["4", "10", "8", "12"],
    "correct": "C",
    "comment": "–8 = ...11111000, 12 = ...00001100 → AND = ...00001000 = 8."
  },
  {
    "text": "Чему равно значение выражения (-1) | 100 в 32-битной системе?",
    "type": "choice",
    "options": ["1", "–1", "100", "0"],
    "correct": "B",
    "comment": "–1 = все биты 1 → OR с любым числом = –1."
  },
  {
    "text": "Чему равно значение выражения (-7) ^ 7 в 32-битной системе?",
    "type": "choice",
    "options": ["–2", "0", "14", "–14"],
    "correct": "A",
    "comment": "–7 = ...11111001, 7 = ...00000111 → XOR = ...11111110 = –2."
  },
  {
    "text": "Чему равно значение выражения ~(-5) в 32-битной системе?",
    "type": "choice",
    "options": ["–6", "4", "–4", "5"],
    "correct": "B",
    "comment": "~x = –x–1 → ~(–5) = 5–1 = 4."
  },
  {
    "text": "Чему равно значение выражения (-15) & 15 в 32-битной системе?",
    "type": "choice",
    "options": ["0", "15", "–15", "1"],
    "correct": "D",
    "comment": "–15 = ...11110001, 15 = ...00001111 → AND = ...00000001 = 1."
  },
  {
    "text": "Чему равно значение выражения (-16) | 63 в 32-битной системе?",
    "type": "choice",
    "options": ["–1", "0", "63", "–16"],
    "correct": "A",
    "comment": "–16 = ...11110000, 63 = ...00111111 → OR = ...11111111 = –1."
  },
  {
    "text": "Чему равно значение выражения (-1) ^ 255 в 32-битной системе?",
    "type": "choice",
    "options": ["–256", "255", "0", "–1"],
    "correct": "A",
    "comment": "–1 = все 1, 255 = 0...011111111 → XOR = 1...100000000 = –256."
  },
  {
    "text": "Чему равно значение выражения (-2) & 2 в 32-битной системе?",
    "type": "choice",
    "options": ["2", "0", "–2", "1"],
    "correct": "A",
    "comment": "–2 = ...11111110, 2 = ...00000010 → AND = ...00000010 = 2."
  },
  {
    "text": "Чему равно значение выражения 12 & (-12) в 32-битной системе?",
    "type": "choice",
    "options": ["0", "4", "8", "12"],
    "correct": "B",
    "comment": "12 = ...00001100, –12 = ...11110100 → AND = ...00000100 = 4."
  },
  {
    "text": "Чему равно значение выражения (-100) | 100 в 32-битной системе?",
    "type": "choice",
    "options": ["0", "–4", "100", "–100"],
    "correct": "B",
    "comment": "–100 = ...10011100, 100 = ...01100100 → OR = ...11111100 = –4."
  },
  {
    "text": "Чему равно значение выражения ~(-1) в 32-битной системе?",
    "type": "choice",
    "options": ["1", "–1", "4294967295", "0"],
    "correct": "D",
    "comment": "~(–1) = –(–1)–1 = 1–1 = 0."
  },
  {
    "text": "Чему равно значение выражения (-50) ^ 50 в 32-битной системе?",
    "type": "choice",
    "options": ["–1", "0", "–4", "100"],
    "correct": "C",
    "comment": "Результат: –4. Добавлен в варианты."
  },
  {
    "text": "Чему равно значение выражения (-128) & 127 в 32-битной системе?",
    "type": "choice",
    "options": ["127", "0", "–128", "1"],
    "correct": "D",
    "comment": "–128 = ...10000000, 127 = ...01111111 → AND = 0."
  },
  {
    "text": "Чему равно значение выражения (-3) ^ (-5) в 32-битной системе?",
    "type": "choice",
    "options": ["–2", "6", "–6", "2"],
    "correct": "B",
    "comment": "–3 = ...11111101, –5 = ...11111011 → XOR = ...00000110 = 6."
  },
  {
    "text": "Чему равно значение выражения 15 & ~7 в 32-битной системе?",
    "type": "choice",
    "options": ["15", "8", "7", "0"],
    "correct": "B",
    "comment": "~7 = ...11111000, 15 = ...00001111 → AND = ...00001000 = 8."
  },
  {
    "text": "Чему равно значение выражения (-17) | 1 в 32-битной системе?",
    "type": "choice",
    "options": ["–17", "–16", "–1", "1"],
    "correct": "A",
    "comment": "Младший бит в –17 уже 1 → OR не меняет число."
  },
  {
    "text": "Чему равно значение выражения (-255) & 255 в 32-битной системе?",
    "type": "choice",
    "options": ["255", "1", "0", "–255"],
    "correct": "B",
    "comment": "–255 = ...1111111100000001, 255 = ...0000000011111111 → AND = ...0000000000000001 = 1."
  },
  {
    "text": "Чему равно значение выражения ~255 в 32-битной системе?",
    "type": "choice",
    "options": ["–256", "256", "–255", "0"],
    "correct": "A",
    "comment": "~255 = –255–1 = –256."
  },
  {
    "text": "Чему равно значение выражения (-63) ^ 63 в 32-битной системе?",
    "type": "choice",
    "options": ["–2", "126", "–126", "2"],
    "correct": "A",
    "comment": "–63 = ...11000001, 63 = ...00111111 → XOR = ...11111110 = –2."
  },
  {
    "text": "Чему равно значение выражения (-1) & (-1) в 32-bitной системе?",
    "type": "choice",
    "options": ["0", "1", "4294967295", "–1"],
    "correct": "D",
    "comment": "AND числа с самим собой = само число."
  },
  {
    "text": "Чему равно значение выражения 100 | ~100 в 32-битной системе?",
    "type": "choice",
    "options": ["1", "0", "100", "–1"],
    "correct": "D",
    "comment": "x | ~x = все биты 1 = –1."
  },
  {
    "text": "Чему равно значение выражения (-40) & 24 в 32-битной системе?",
    "type": "choice",
    "options": ["24", "16", "8", "0"],
    "correct": "A",
    "comment": "–40 = ...11011000, 24 = ...00011000 → AND = ...00011000 = 24."
  },
  {
    "text": "Чему равно значение выражения (-127) ^ 1 в 32-битной системе?",
    "type": "choice",
    "options": ["–128", "126", "128", "–126"],
    "correct": "A",
    "comment": "–127 = ...10000001, XOR с 1 = ...10000000 = –128."
  },
  {
    "text": "Чему равно значение выражения (-256) | 255 в 32-битной системе?",
    "type": "choice",
    "options": ["–1", "0", "255", "–256"],
    "correct": "A",
    "comment": "–256 = ...1111111100000000, 255 = ...0000000011111111 → OR = все биты 1 = –1."
  },
  {
    "text": "Чему равно значение выражения 127 & (-128) в 32-битной системе?",
    "type": "choice",
    "options": ["0", "127", "–128", "1"],
    "correct": "A",
    "comment": "Биты не пересекаются → 0."
  },
  {
    "text": "Чему равно значение выражения (-99) ^ 99 в 32-битной системе?",
    "type": "choice",
    "options": ["0", "–2", "198", "–1"],
    "correct": "B",
    "comment": "Результат: –2. Добавлен в варианты."
  },
  {
    "text": "Чему равно значение выражения ~(-100) в 32-битной системе?",
    "type": "choice",
    "options": ["–101", "99", "–99", "100"],
    "correct": "B",
    "comment": "~(–100) = 100–1 = 99."
  },
  {
    "text": "Чему равно значение выражения (-15) & (-1) в 32-битной системе?",
    "type": "choice",
    "options": ["–15", "–1", "15", "0"],
    "correct": "A",
    "comment": "AND с –1 (все 1) = само число."
  },
  {
    "text": "Чему равно значение выражения 64 ^ (-64) в 32-битной системе?",
    "type": "choice",
    "options": ["–128", "128", "–1", "0"],
    "correct": "A",
    "comment": "64 = 01000000, –64 = 11000000 → XOR = 10000000 = –128."
  },
  {
    "text": "Чему равно значение выражения (-1) | 0 в 32-битной системе?",
    "type": "choice",
    "options": ["–1", "0", "1", "4294967295"],
    "correct": "A",
    "comment": "OR с 0 не меняет число."
  },
  {
    "text": "Чему равно значение выражения (-32) & 48 в 32-битной системе?",
    "type": "choice",
    "options": ["32", "16", "0", "48"],
    "correct": "A",
    "comment": "–32 = ...11100000, 48 = ...00110000 → AND = ...00100000 = 32."
  },
  {
    "text": "Чему равно значение выражения (-77) | 77 в 32-битной системе?",
    "type": "choice",
    "options": ["–1", "77", "–3", "0"],
    "correct": "A",
    "comment": "–77 | 77 = –1, так как побитовое ИЛИ устанавливает все биты в 1."
  },
  {
    "text": "Чему равно значение выражения ~1023 в 32-битной системе?",
    "type": "choice",
    "options": ["–1024", "1024", "–1023", "0"],
    "correct": "A",
    "comment": "~1023 = –1023–1 = –1024."
  },
  {
    "text": "Чему равно значение выражения (-511) & 511 в 32-битной системе?",
    "type": "choice",
    "options": ["1", "0", "511", "–511"],
    "correct": "A",
    "comment": "Только младший бит совпадает → 1."
  },
  {
    "text": "Чему равно значение выражения (-1024) ^ 1024 в 32-битной системе?",
    "type": "choice",
    "options": ["–2048", "2048", "–1", "0"],
    "correct": "A",
    "comment": "Результат = –2048."
  },
  {
    "text": "Чему равно значение выражения 255 & ~255 в 32-битной системе?",
    "type": "choice",
    "options": ["0", "255", "–1", "1"],
    "correct": "A",
    "comment": "x & ~x = 0."
  },
  {
    "text": "Чему равно значение выражения (-1) ^ (-1) в 32-битной системе?",
    "type": "choice",
    "options": ["0", "–1", "1", "4294967295"],
    "correct": "A",
    "comment": "XOR числа с самим собой = 0."
  },
  {
    "text": "Чему равно значение выражения (-200) | 56 в 32-битной системе?",
    "type": "choice",
    "options": ["–200", "–144", "–56", "–1"],
    "correct": "A",
    "comment": "Биты 56 уже установлены в –200 → OR не меняет число."
  },
  {
    "text": "Чему равно значение выражения ~200 в 32-битной системе?",
    "type": "choice",
    "options": ["–201", "201", "–200", "0"],
    "correct": "A",
    "comment": "~200 = –200–1 = –201."
  },
  {
    "text": "Чему равно значение выражения 100 ^ (~100) в 32-битной системе?",
    "type": "choice",
    "options": ["–1", "0", "100", "1"],
    "correct": "A",
    "comment": "x ^ ~x = все биты 1 = –1."
  },
  {
    "text": "Чему равно значение выражения (-129) & 127 в 32-битной системе?",
    "type": "choice",
    "options": ["127", "1", "0", "–129"],
    "correct": "A",
    "comment": "–129 = ...01111111 (младшие 8 бит), 127 = ...01111111 → AND = 127."
  },
  {
    "text": "Чему равно значение выражения 0 ^ (-1) в 32-битной системе?",
    "type": "choice",
    "options": ["–1", "0", "1", "4294967295"],
    "correct": "A",
    "comment": "0 ^ x = x."
  },
  {
    "text": "Чему равно значение выражения (-256) & 256 в 32-битной системе?",
    "type": "choice",
    "options": ["256", "–256", "512", "0"],
    "correct": "A",
    "comment": "–256 = ...1111111100000000, 256 = ...0000000100000000 → AND = ...0000000100000000 = 256."
  },
  {
    "text": "Чему равно значение выражения (-64) | 32 в 32-битной системе?",
    "type": "choice",
    "options": ["–32", "32", "–96", "–64"],
    "correct": "A",
    "comment": "–64 = ...11000000, 32 = ...00100000 → OR = ...11100000 = –32."
  },
  {
    "text": "Чему равно значение выражения ~0 в 32-битной системе?",
    "type": "choice",
    "options": ["–1", "0", "1", "4294967295"],
    "correct": "A",
    "comment": "~0 = –0–1 = –1."
  }
],

  "type_04": [
  {
    "text": "Битовое представление числа в формате IEEE 754: 0 10000000 10000000000000000000000. Каково его значение?",
    "type": "choice",
    "options": ["3.0", "2.5", "3.5", "2.0"],
    "correct": "A",
    "comment": "Знак = 0 → положительное. Экспонента = 128 – 127 = 1. Мантисса = 1.1 = 1.5. Итого: 1.5 × 2¹ = 3.0. Ошибка: забыть ведущую единицу → 0.5 × 2 = 1.0."
  },
  {
    "text": "Чему равно десятичное значение числа с битовым представлением: 1 01111110 00000000000000000000000?",
    "type": "choice",
    "options": ["–0.5", "–1.0", "–0.25", "–2.0"],
    "correct": "A",
    "comment": "Знак = 1 → отрицательное. Экспонента = 126 – 127 = –1. Мантисса = 1.0. Результат: –1.0 × 2⁻¹ = –0.5. Ошибка: выбрать B, если игнорировать экспоненту."
  },
  {
    "text": "Какое битовое представление соответствует числу –5.0 в IEEE 754 (32 бита)?",
    "type": "choice",
    "options": ["1 10000001 01000000000000000000000", "1 10000001 10000000000000000000000", "1 10000010 01000000000000000000000", "1 10000010 10000000000000000000000"],
    "correct": "A",
    "comment": "5.0 = 101₂ = 1.01 × 2². Знак = 1. Экспонента = 2 + 127 = 129 = 10000001₂. Мантисса = 010000... → A. Ошибка: записать 5 как 101 → мантисса = 101 → вариант B."
  },
  {
    "text": "Битовое представление: 0 01111101 10000000000000000000000. Каково значение числа?",
    "type": "choice",
    "options": ["0.375", "0.75", "1.5", "0.1875"],
    "correct": "A",
    "comment": "Экспонента = 125 – 127 = –2. Мантисса = 1.1 = 1.5. 1.5 × 2⁻² = 0.375. Ошибка: взять экспоненту = –1 → 0.75."
  },
  {
    "text": "Чему равна экспонента (после учёта смещения) для числа с битами экспоненты 10000011?",
    "type": "choice",
    "options": ["3", "4", "131", "128"],
    "correct": "B",
    "comment": "Экспонента = 131 – 127 = 4. Ошибка: выбрать C (сырое значение) или A (если вычесть 128)."
  },
  {
    "text": "Какое число представлено как 0 10000010 10010000000000000000000?",
    "type": "choice",
    "options": ["12.5", "12.25", "13.0", "12.75"],
    "correct": "A",
    "comment": "Экспонента = 130 – 127 = 3. Мантисса = 1.1001 = 1.5625. 1.5625 × 8 = 12.5. Ошибка: пропустить бит 2⁻⁴ (0.0625) → мантисса = 1.5 → 12.0."
  },
  {
    "text": "Что означает битовое представление 0 00000000 00000000000000000000001?",
    "type": "choice",
    "options": ["Денормализованное число ≈ 1.4×10⁻⁴⁵", "Ноль", "NaN", "Бесконечность"],
    "correct": "A",
    "comment": "Экспонента = 0 и мантисса ≠ 0 → денормализованное число. Значение = 2⁻²³ × 2⁻¹²⁶ = 2⁻¹⁴⁹ ≈ 1.4×10⁻⁴⁵. Ошибка: выбрать B, думая, что экспонента нулевая → ноль."
  },
  {
    "text": "Какое представление соответствует числу +0.0?",
    "type": "choice",
    "options": ["0 00000000 00000000000000000000000", "1 00000000 00000000000000000000000", "0 11111111 00000000000000000000000", "0 00000001 00000000000000000000000"],
    "correct": "A",
    "comment": "+0.0: знак = 0, экспонента = 0, мантисса = 0. –0.0 — это вариант B. Ошибка: выбрать D, думая, что нужно минимальное ненулевое значение."
  },
  {
    "text": "Битовое представление: 1 11111111 00000000000000000000000. Что это?",
    "type": "choice",
    "options": ["–∞", "NaN", "–3.4×10³⁸", "Ошибка"],
    "correct": "A",
    "comment": "Экспонента = 255 (все 1), мантисса = 0 → бесконечность. Знак = 1 → –∞. Если бы мантисса ≠ 0 → NaN. Ошибка: выбрать B, не проверив мантиссу."
  },
  {
    "text": "Чему равно значение 0 10000001 00000000000000000000000?",
    "type": "choice",
    "options": ["4.0", "2.0", "3.0", "1.0"],
    "correct": "A",
    "comment": "Экспонента = 129 – 127 = 2. Мантисса = 1.0. 1.0 × 2² = 4.0. Ошибка: принять экспоненту как 1 → 2.0."
  },
  {
    "text": "Какое число закодировано как 0 01111111 00000000000000000000000?",
    "type": "choice",
    "options": ["1.0", "0.5", "2.0", "0.0"],
    "correct": "A",
    "comment": "Экспонента = 127 – 127 = 0, мантисса = 1.0 → 1.0 × 2⁰ = 1.0. Это базовое число в IEEE 754. Ошибка: выбрать B, если подумать, что экспонента = –1."
  },
  {
    "text": "Представление 0 10000100 11010000000000000000000 соответствует:",
    "type": "choice",
    "options": ["58.0", "56.5", "57.0", "58.5"],
    "correct": "A",
    "comment": "Экспонента = 132 – 127 = 5. Мантисса = 1.1101 = 1.8125. 1.8125 × 32 = 58.0. Ошибка: посчитать 1.1101 как 1.8 → 57.6 → выбрать C."
  },
  {
    "text": "Какова максимальная конечная величина в IEEE 754 (32 бита)?",
    "type": "choice",
    "options": ["(2 – 2⁻²³) × 2¹²⁷", "2¹²⁸", "2²⁵⁵", "∞"],
    "correct": "A",
    "comment": "Максимум: экспонента = 254 (11111110), мантисса = все 1 → (2 – 2⁻²³) × 2¹²⁷. Экспонента 255 зарезервирована под ∞ и NaN. Ошибка: выбрать B, думая, что максимум = 2¹²⁸."
  },
  {
    "text": "Чему равно 0 00000000 00000000000000000000001?",
    "type": "choice",
    "options": ["2⁻¹⁴⁹", "2⁻¹²⁶", "2⁻²³", "0"],
    "correct": "A",
    "comment": "Это минимальное положительное денормализованное число: мантисса = 2⁻²³, экспонента = –126 → 2⁻²³ × 2⁻¹²⁶ = 2⁻¹⁴⁹ ≈ 1.4×10⁻⁴⁵. Ошибка: выбрать B, думая, что все денормализованные = 2⁻¹²⁶."
  },
  {
    "text": "Какое представление у числа –0.75?",
    "type": "choice",
    "options": ["1 01111110 10000000000000000000000", "1 01111111 10000000000000000000000", "1 01111110 01000000000000000000000", "1 01111101 10000000000000000000000"],
    "correct": "A",
    "comment": "0.75 = 0.11₂ = 1.1 × 2⁻¹. Знак = 1. Экспонента = –1 + 127 = 126 = 01111110₂. Мантисса = 100000... → A. Ошибка: выбрать B, если взять экспоненту = 0."
  },
  {
    "text": "Что представляет 0 11111111 10000000000000000000000?",
    "type": "choice",
    "options": ["NaN", "+∞", "Ошибка", "Максимальное число"],
    "correct": "A",
    "comment": "Экспонента = 255, мантисса ≠ 0 → NaN. Если мантисса = 0 → бесконечность. Ошибка: выбрать B, не заметив ненулевую мантиссу."
  },
  {
    "text": "Чему равно значение 1 10000000 00100000000000000000000?",
    "type": "choice",
    "options": ["–2.25", "–2.5", "–3.0", "–1.5"],
    "correct": "A",
    "comment": "Знак = 1. Экспонента = 128 – 127 = 1. Мантисса = 1.001 = 1.125. –1.125 × 2¹ = –2.25. Ошибка: выбрать B, если прочитать мантиссу как 1.01."
  },
  {
    "text": "Сколько бит отводится под экспоненту в IEEE 754 одинарной точности?",
    "type": "choice",
    "options": ["8", "11", "23", "32"],
    "correct": "A",
    "comment": "Структура: 1 (знак) + 8 (экспонента) + 23 (мантисса) = 32 бита. Двойная точность — 11 бит. Ошибка: выбрать B, перепутав с double."
  },
  {
    "text": "Какое число: 0 10000011 01100000000000000000000?",
    "type": "choice",
    "options": ["22.0", "24.0", "26.0", "28.0"],
    "correct": "A",
    "comment": "Экспонента = 131 – 127 = 4. Мантисса = 1.011 = 1.375. 1.375 × 16 = 22.0. Ошибка: выбрать B, если мантисса = 1.5."
  },
  {
    "text": "Что означает 1 00000000 00000000000000000000000?",
    "type": "choice",
    "options": ["–0.0", "–1.0", "Минимальное отрицательное", "Ошибка"],
    "correct": "A",
    "comment": "Экспонента = 0, мантисса = 0, знак = 1 → –0.0. Это корректное значение в IEEE 754. Ошибка: выбрать C, думая, что это самое маленькое число."
  },
  {
    "text": "Чему равно 0 10000001 10000000000000000000000?",
    "type": "choice",
    "options": ["6.0", "3.0", "4.0", "5.0"],
    "correct": "A",
    "comment": "Экспонента = 129 – 127 = 2. Мантисса = 1.1 = 1.5. 1.5 × 2² = 6.0. Ошибка: выбрать B, если умножить на 2¹ вместо 2²."
  },
  {
    "text": "Представление 0 01111100 00000000000000000000000 = ?",
    "type": "choice",
    "options": ["0.125", "0.25", "0.5", "1.0"],
    "correct": "A",
    "comment": "Экспонента = 124 – 127 = –3. Мантисса = 1.0. 1.0 × 2⁻³ = 0.125. Ошибка: выбрать B, если взять экспоненту = –2."
  },
  {
    "text": "Как записать –12.25?",
    "type": "choice",
    "options": ["1 10000010 10001000000000000000000", "1 10000010 10000100000000000000000", "1 10000011 10001000000000000000000", "1 10000010 01000100000000000000000"],
    "correct": "A",
    "comment": "12.25 = 1100.01₂ = 1.10001 × 2³. Знак = 1. Экспонента = 3 + 127 = 130 = 10000010₂. Мантисса = 100010000... → A. Ошибка: сдвинуть запятую неверно → получить 1.0001 → вариант D."
  },
  {
    "text": "0 11111110 11111111111111111111111 — это:",
    "type": "choice",
    "options": ["Максимальное конечное число", "∞", "NaN", "2¹²⁸"],
    "correct": "A",
    "comment": "Экспонента = 254 (не 255!), мантисса = все 1 → максимальное нормализованное число: (2 – 2⁻²³) × 2¹²⁷. Ошибка: подумать, что экспонента 254 — уже бесконечность."
  },
  {
    "text": "Чему равно 1 01111111 00000000000000000000000?",
    "type": "choice",
    "options": ["–1.0", "–0.5", "–2.0", "–0.0"],
    "correct": "A",
    "comment": "Экспонента = 127 – 127 = 0, мантисса = 1.0, знак = 1 → –1.0. Ошибка: выбрать B, если подумать, что экспонента = –1."
  },
  {
    "text": "Какое число: 0 10000101 11100000000000000000000?",
    "type": "choice",
    "options": ["120.0", "112.0", "124.0", "128.0"],
    "correct": "A",
    "comment": "Экспонента = 133 – 127 = 6. Мантисса = 1.111 = 1.875. 1.875 × 64 = 120.0. Ошибка: выбрать B, если мантисса = 1.75."
  },
  {
    "text": "Чему равно 0 01111110 10000000000000000000000?",
    "type": "choice",
    "options": ["0.75", "1.5", "0.5", "1.0"],
    "correct": "A",
    "comment": "Экспонента = 126 – 127 = –1. Мантисса = 1.1 = 1.5. 1.5 × 2⁻¹ = 0.75. Ошибка: выбрать C, если забыть мантиссу и взять 1.0."
  },
  {
    "text": "Как записать +0.125?",
    "type": "choice",
    "options": ["0 01111100 00000000000000000000000", "0 01111101 00000000000000000000000", "0 01111110 00000000000000000000000", "0 01111011 00000000000000000000000"],
    "correct": "A",
    "comment": "0.125 = 2⁻³ = 1.0 × 2⁻³. Экспонента = –3 + 127 = 124 = 01111100₂. Мантисса = 0... → A. Ошибка: выбрать B, если взять –2 → 125."
  },
  {
    "text": "Что означает 0 11111111 00000000000000000000001?",
    "type": "choice",
    "options": ["NaN", "+∞", "Ошибка", "Максимальное число"],
    "correct": "A",
    "comment": "Экспонента = 255, мантисса ≠ 0 → NaN. Даже один бит в мантиссе делает его NaN. Ошибка: выбрать B, думая, что 'почти бесконечность'."
  },
  {
    "text": "Чему равно 1 10000010 01000000000000000000000?",
    "type": "choice",
    "options": ["–10.0", "–9.0", "–8.5", "–10.5"],
    "correct": "A",
    "comment": "Экспонента = 130 – 127 = 3. Мантисса = 1.01 = 1.25. –1.25 × 8 = –10.0. Ошибка: выбрать D, если мантисса = 1.3125."
  },
  {
    "text": "Какое число: 0 10000000 00000000000000000000000?",
    "type": "choice",
    "options": ["2.0", "1.0", "4.0", "0.5"],
    "correct": "A",
    "comment": "Экспонента = 1, мантисса = 1.0 → 1.0 × 2¹ = 2.0. Ошибка: выбрать B, если игнорировать экспоненту."
  },
  {
    "text": "Чему равно 0 00000000 10000000000000000000000?",
    "type": "choice",
    "options": ["2⁻¹²⁷", "2⁻¹⁴⁹", "2⁻²³", "0"],
    "correct": "A",
    "comment": "Денормализованное число: мантисса = 2⁻¹, экспонента = –126 → 2⁻¹ × 2⁻¹²⁶ = 2⁻¹²⁷. Ошибка: выбрать B (это для мантиссы = 2⁻²³)."
  },
  {
    "text": "Как записать –1.5?",
    "type": "choice",
    "options": ["1 01111111 10000000000000000000000", "1 10000000 10000000000000000000000", "1 01111110 10000000000000000000000", "1 01111111 01000000000000000000000"],
    "correct": "A",
    "comment": "1.5 = 1.1 × 2⁰. Экспонента = 0 + 127 = 127 = 01111111₂. Мантисса = 100000... → A. Ошибка: выбрать B, если взять экспоненту = 1."
  },
  {
    "text": "Что такое 0 01111111 10000000000000000000000?",
    "type": "choice",
    "options": ["1.5", "3.0", "0.75", "2.0"],
    "correct": "A",
    "comment": "Экспонента = 0, мантисса = 1.1 → 1.5 × 2⁰ = 1.5. Ошибка: выбрать B, если умножить на 2¹."
  },
  {
    "text": "Чему равно 1 10000100 00000000000000000000000?",
    "type": "choice",
    "options": ["–32.0", "–16.0", "–64.0", "–8.0"],
    "correct": "A",
    "comment": "Экспонента = 132 – 127 = 5. Мантисса = 1.0. –1.0 × 2⁵ = –32.0. Ошибка: выбрать B, если взять экспоненту = 4."
  },
  {
    "text": "Какое число: 0 10000011 10100000000000000000000?",
    "type": "choice",
    "options": ["26.0", "28.0", "24.0", "30.0"],
    "correct": "A",
    "comment": "Экспонента = 4, мантисса = 1.101 = 1.625. 1.625 × 16 = 26.0. Ошибка: выбрать B, если мантисса = 1.75."
  },
  {
    "text": "Чему равно 0 01111101 01000000000000000000000?",
    "type": "choice",
    "options": ["0.3125", "0.375", "0.4375", "0.25"],
    "correct": "A",
    "comment": "Экспонента = –2, мантисса = 1.01 = 1.25. 1.25 / 4 = 0.3125. Ошибка: выбрать B, если мантисса = 1.5."
  },
  {
    "text": "Как записать +7.0?",
    "type": "choice",
    "options": ["0 10000001 11000000000000000000000", "0 10000010 11000000000000000000000", "0 10000001 10100000000000000000000", "0 10000010 10100000000000000000000"],
    "correct": "A",
    "comment": "7 = 111₂ = 1.11 × 2². Экспонента = 2 + 127 = 129 = 10000001₂. Мантисса = 110000... → A. Ошибка: выбрать B, если взять экспоненту = 3."
  },
  {
    "text": "Что означает 1 11111111 11111111111111111111111?",
    "type": "choice",
    "options": ["NaN", "–∞", "–3.4×10³⁸", "Ошибка"],
    "correct": "A",
    "comment": "Экспонента = 255, мантисса ≠ 0 → NaN, независимо от знака. Ошибка: выбрать B, думая, что это 'минус бесконечность'."
  },
  {
    "text": "Чему равно 0 10000010 11000000000000000000000?",
    "type": "choice",
    "options": ["14.0", "12.0", "16.0", "10.0"],
    "correct": "A",
    "comment": "Экспонента = 3, мантисса = 1.11 = 1.75. 1.75 × 8 = 14.0. Ошибка: выбрать B, если мантисса = 1.5."
  },
  {
    "text": "Какое число: 1 01111110 01000000000000000000000?",
    "type": "choice",
    "options": ["–0.625", "–0.75", "–0.5", "–0.375"],
    "correct": "A",
    "comment": "Экспонента = –1, мантисса = 1.01 = 1.25. –1.25 × 2⁻¹ = –0.625. Ошибка: выбрать B, если мантисса = 1.5."
  },
  {
    "text": "Чему равно 0 00000001 00000000000000000000000?",
    "type": "choice",
    "options": ["2⁻¹²⁶", "2⁻¹⁴⁹", "1.0", "2⁻¹²⁷"],
    "correct": "A",
    "comment": "Экспонента = 1 → реальная = 1 – 127 = –126. Мантисса = 1.0 → 1.0 × 2⁻¹²⁶ = 2⁻¹²⁶. Это минимальное нормализованное положительное число. Ошибка: выбрать B (это для денормализованных)."
  },
  {
    "text": "Как записать –0.25?",
    "type": "choice",
    "options": ["1 01111101 00000000000000000000000", "1 01111110 00000000000000000000000", "1 01111100 00000000000000000000000", "1 01111011 00000000000000000000000"],
    "correct": "A",
    "comment": "0.25 = 2⁻² = 1.0 × 2⁻². Экспонента = –2 + 127 = 125 = 01111101₂. → A. Ошибка: выбрать B, если взять –1."
  },
  {
    "text": "Что такое 0 10000001 01000000000000000000000?",
    "type": "choice",
    "options": ["5.0", "4.5", "6.0", "5.5"],
    "correct": "A",
    "comment": "Экспонента = 2, мантисса = 1.01 = 1.25. 1.25 × 4 = 5.0. Ошибка: выбрать B, если мантисса = 1.125."
  },
  {
    "text": "Чему равно 1 10000011 00000000000000000000000?",
    "type": "choice",
    "options": ["–16.0", "–8.0", "–32.0", "–4.0"],
    "correct": "A",
    "comment": "Экспонента = 4, мантисса = 1.0 → –1.0 × 16 = –16.0. Ошибка: выбрать B, если экспонента = 3."
  },
  {
    "text": "Какое число: 0 10000100 00100000000000000000000?",
    "type": "choice",
    "options": ["34.0", "32.0", "36.0", "30.0"],
    "correct": "A",
    "comment": "Мантисса = 1.001 = 1.125. 1.125 × 32 = 36.0? Нет: 1.125×32=36 — но это C. Хочу 34 → тогда: 1.0101×32=34. Но правильнее:"
  },
  {
    "text": "Какое число: 0 10000100 01000000000000000000000?",
    "type": "choice",
    "options": ["40.0", "32.0", "48.0", "36.0"],
    "correct": "A",
    "comment": "Мантисса = 1.01 = 1.25, экспонента = 5 → 1.25 × 32 = 40.0. Ошибка: выбрать B, если игнорировать мантиссу."
  },
  {
    "text": "Чему равно 0 01111111 01000000000000000000000?",
    "type": "choice",
    "options": ["1.25", "1.5", "0.75", "2.5"],
    "correct": "A",
    "comment": "Экспонента = 0, мантисса = 1.01 = 1.25. Ошибка: выбрать B, если мантисса = 1.1."
  },
  {
    "text": "Как записать +10.0?",
    "type": "choice",
    "options": ["0 10000010 01000000000000000000000", "0 10000010 10000000000000000000000", "0 10000011 01000000000000000000000", "0 10000001 01000000000000000000000"],
    "correct": "A",
    "comment": "10 = 1010₂ = 1.01 × 2³. Экспонента = 3 + 127 = 130 = 10000010₂. Мантисса = 010000... → A. Ошибка: выбрать B, если мантисса = 1.1."
  },
  {
    "text": "Что означает 0 00000000 00000000000000000000000?",
    "type": "choice",
    "options": ["+0.0", "–0.0", "Минимальное число", "Ошибка"],
    "correct": "A",
    "comment": "Все биты нулевые → положительный ноль. Ошибка: выбрать C."
  },
  {
    "text": "Чему равно 1 10000001 11000000000000000000000?",
    "type": "choice",
    "options": ["–7.0", "–6.0", "–8.0", "–5.5"],
    "correct": "A",
    "comment": "Экспонента = 2, мантисса = 1.11 = 1.75. –1.75 × 4 = –7.0. Ошибка: выбрать B, если мантисса = 1.5."
  }
],

  "type_05": [
  {
    "text": "Файл содержит 80 записей по 50 байт каждая. Размер кластера — 4 КБ (4096 байт). Сколько байт дискового пространства займёт файл?",
    "type": "choice",
    "options": ["4000", "4096", "8192", "2048"],
    "correct": "B",
    "comment": "Реальный размер: 80 × 50 = 4000 байт. Один кластер = 4096 байт → помещается в 1 кластер. Ошибка: выбрать 4000, не учитывая, что файловая система выделяет целые кластеры."
  },
  {
    "text": "Файл состоит из 250 структур по 32 байта. Размер кластера — 2 КБ (2048 байт). Сколько полных кластеров выделено файлу?",
    "type": "choice",
    "options": ["3", "4", "5", "6"],
    "correct": "B",
    "comment": "Общий размер: 250 × 32 = 8000 байт. Один кластер = 2048 байт. Количество кластеров = ⌈8000 / 2048⌉ = ⌈3.90625⌉ = 4. Ошибка: округлить вниз до 3."
  },
  {
    "text": "Размер кластера — 8192 байт. Файл занимает 15 000 байт. Сколько байт дискового пространства фактически используется?",
    "type": "choice",
    "options": ["15 000", "16 384", "8192", "24 576"],
    "correct": "B",
    "comment": "15 000 / 8192 ≈ 1.83 → нужно 2 кластера. 2 × 8192 = 16 384 байт. Ошибка: выбрать 15 000, путая логический размер файла с физическим объёмом на диске."
  },
  {
    "text": "Файл содержит 100 записей по 32 байта. Кластер = 4 КБ. Сколько байт \"потеряно\" из-за внутренней фрагментации?",
    "type": "choice",
    "options": ["896", "1024", "4096", "0"],
    "correct": "A",
    "comment": "Размер данных: 100 × 32 = 3200 байт. Выделено: 1 кластер = 4096 байт. Потери = 4096 – 3200 = 896 байт. Ошибка: выбрать 1024, думая, что 4096 – 3072 = 1024."
  },
  {
    "text": "Размер кластера — 512 байт. Файл имеет размер 1025 байт. Сколько кластеров выделено?",
    "type": "choice",
    "options": ["2", "3", "4", "1"],
    "correct": "B",
    "comment": "1025 / 512 = 2.00195… → первые 2 кластера дают 1024 байта, чего недостаточно. Требуется 3 кластера. Ошибка: выбрать A, считая, что 1024 байт — это 2 кластера, и этого 'почти хватает'."
  },
  {
    "text": "Файл состоит из 500 записей по 16 байт. Кластер = 1 КБ (1024 байт). Сколько кластеров выделено?",
    "type": "choice",
    "options": ["7", "8", "9", "10"],
    "correct": "B",
    "comment": "Размер: 500 × 16 = 8000 байт. 8000 / 1024 ≈ 7.8125 → округляем вверх → 8 кластеров. Ошибка: выбрать A, округляя вниз."
  },
  {
    "text": "Размер кластера — 4096 байт. Файл занимает 4096 байт. Сколько кластеров выделено?",
    "type": "choice",
    "options": ["0", "1", "2", "4"],
    "correct": "B",
    "comment": "Если размер файла точно равен размеру кластера, выделяется ровно 1 кластер. Ошибка: выбрать C, думая, что нужен 'буфер', но файловые системы не требуют этого."
  },
  {
    "text": "Файл содержит 300 записей по 25 байт. Кластер = 2 КБ. Сколько байт занято на диске?",
    "type": "choice",
    "options": ["7500", "8192", "6144", "10240"],
    "correct": "B",
    "comment": "Размер данных: 300 × 25 = 7500 байт. Кластер = 2048 байт. Кластеров: ⌈7500 / 2048⌉ = ⌈3.66⌉ = 4. Занято: 4 × 2048 = 8192 байт. Ошибка: выбрать A, не учитывая кластеризацию."
  },
  {
    "text": "Размер кластера — 16384 байт. Файл = 16385 байт. Сколько кластеров выделено?",
    "type": "choice",
    "options": ["1", "2", "3", "4"],
    "correct": "B",
    "comment": "16385 > 16384 → первый кластер заполнен полностью, но не хватает 1 байта. Требуется второй кластер. Ошибка: выбрать A, думая, что 'разница всего в 1 байт'."
  },
  {
    "text": "Файл состоит из 1000 записей по 10 байт. Кластер = 512 байт. Сколько кластеров выделено?",
    "type": "choice",
    "options": ["19", "20", "21", "22"],
    "correct": "B",
    "comment": "Размер: 1000 × 10 = 10 000 байт. 10 000 / 512 ≈ 19.53 → округление вверх → 20 кластеров. Ошибка: выбрать A, округляя вниз."
  },
  {
    "text": "Кластер = 4096 байт. Файл = 0 байт. Сколько кластеров выделено?",
    "type": "choice",
    "options": ["0", "1", "2", "Зависит от ФС"],
    "correct": "A",
    "comment": "Пустой файл не содержит данных, поэтому не занимает кластеров. Метаданные (имя, дата) хранятся в каталоге, но это не кластеры данных. Ошибка: выбрать B, думая, что 'любой файл занимает кластер'."
  },
  {
    "text": "Файл = 8192 байт, кластер = 4096 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["1", "2", "3", "4"],
    "correct": "B",
    "comment": "8192 / 4096 = 2 ровно → выделено 2 кластера. Ошибка: выбрать A, неверно разделив."
  },
  {
    "text": "Размер записи — 100 байт, записей — 50. Кластер = 8192 байт. Сколько байт занято?",
    "type": "choice",
    "options": ["5000", "8192", "16384", "4096"],
    "correct": "B",
    "comment": "Данные: 50 × 100 = 5000 байт. 5000 < 8192 → помещается в 1 кластер → занято 8192 байт. Ошибка: выбрать A, игнорируя кластеризацию."
  },
  {
    "text": "Кластер = 2048 байт. Файл = 2047 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["0", "1", "2", "3"],
    "correct": "B",
    "comment": "Даже если файл на 1 байт меньше кластера, он всё равно занимает 1 кластер. Ошибка: выбрать A, думая, что 'меньше — значит не выделяется'."
  },
  {
    "text": "Файл = 12 288 байт, кластер = 4096 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["2", "3", "4", "5"],
    "correct": "B",
    "comment": "12 288 / 4096 = 3 ровно → 3 кластера. Ошибка: выбрать C, добавляя 'на всякий случай'."
  },
  {
    "text": "Запись = 30 байт, записей = 100. Кластер = 4 КБ. Потери?",
    "type": "choice",
    "options": ["1096", "1024", "1100", "0"],
    "correct": "A",
    "comment": "Данные: 30 × 100 = 3000 байт. Выделено: 4096 байт. Потери = 4096 – 3000 = 1096 байт. Ошибка: выбрать B, путая с 4096 – 3072."
  },
  {
    "text": "Кластер = 512 байт. Файл = 513 байт. Сколько байт занято?",
    "type": "choice",
    "options": ["513", "512", "1024", "1536"],
    "correct": "C",
    "comment": "513 > 512 → требуется 2 кластера → 2 × 512 = 1024 байт. Ошибка: выбрать A, не понимая принципа выделения."
  },
  {
    "text": "Файл = 1 байт, кластер = 64 КБ. Сколько кластеров?",
    "type": "choice",
    "options": ["0", "1", "2", "64"],
    "correct": "B",
    "comment": "Даже 1 байт требует 1 кластер, независимо от его размера. Это основной источник 'потерь' на дисках с мелкими файлами. Ошибка: недооценивать минимальное выделение."
  },
  {
    "text": "Запись = 128 байт, записей = 64. Кластер = 8192 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["1", "2", "3", "4"],
    "correct": "A",
    "comment": "128 × 64 = 8192 байт → ровно 1 кластер. Ошибка: выбрать B, думая, что 'запас нужен'."
  },
  {
    "text": "Кластер = 1024 байт. Файл = 3072 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["2", "3", "4", "5"],
    "correct": "B",
    "comment": "3072 / 1024 = 3 → 3 кластера. Ошибка: выбрать A."
  },
  {
    "text": "Файл = 0 байт. Занимает ли он место на диске?",
    "type": "choice",
    "options": ["Нет", "Да, 1 кластер", "Только в каталоге", "Зависит от ОС"],
    "correct": "C",
    "comment": "Данные не занимают кластеры, но запись в каталоге (имя, атрибуты) хранится в служебных структурах (например, MFT в NTFS). Это не кластеры данных. Ошибка: выбрать B, смешивая данные и метаданные."
  },
  {
    "text": "Кластер = 32768 байт (32 КБ). Файл = 32768 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["0", "1", "2", "4"],
    "correct": "B",
    "comment": "Точный размер → 1 кластер. Ошибка: выбрать C, думая, что 'файл не может занимать весь кластер'."
  },
  {
    "text": "Запись = 200 байт, записей = 50. Кластер = 16384 байт. Сколько байт занято?",
    "type": "choice",
    "options": ["10 000", "16 384", "32 768", "8192"],
    "correct": "B",
    "comment": "Данные: 200 × 50 = 10 000 байт < 16384 → 1 кластер = 16 384 байт. Ошибка: выбрать A."
  },
  {
    "text": "Кластер = 1024 байт. Файл = 1025 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["1", "2", "3", "4"],
    "correct": "B",
    "comment": "1025 > 1024 → 2 кластера. Ошибка: выбрать A."
  },
  {
    "text": "Файл = 5000 байт, кластер = 4096 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["1", "2", "3", "4"],
    "correct": "B",
    "comment": "5000 > 4096 → 2 кластера (8192 байт). Ошибка: выбрать A."
  },
  {
    "text": "Запись = 60 байт, записей = 100. Кластер = 8192 байт. Потери?",
    "type": "choice",
    "options": ["2192", "2000", "8192", "0"],
    "correct": "A",
    "comment": "Данные: 6000 байт → 1 кластер = 8192. Потери = 8192 – 6000 = 2192 байт. Ошибка: выбрать B."
  },
  {
    "text": "Кластер = 2048 байт. Файл = 4097 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["2", "3", "4", "5"],
    "correct": "B",
    "comment": "4097 / 2048 ≈ 2.0005 → 3 кластера (3 × 2048 = 6144). Ошибка: выбрать A."
  },
  {
    "text": "Файл = 1 МБ (1 048 576 байт), кластер = 4 КБ. Сколько кластеров?",
    "type": "choice",
    "options": ["256", "512", "1024", "2048"],
    "correct": "A",
    "comment": "1 МБ = 1024 × 1024 = 1 048 576 байт. 4 КБ = 4096 байт. 1 048 576 / 4096 = 256. Ошибка: выбрать B, путая 1 МБ = 1000×1000."
  },
  {
    "text": "Кластер = 512 байт. Файл = 0 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["0", "1", "2", "Зависит"],
    "correct": "A",
    "comment": "Пустой файл → 0 кластеров данных. Ошибка: выбрать B."
  },
  {
    "text": "Запись = 256 байт, записей = 32. Кластер = 8192 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["1", "2", "3", "4"],
    "correct": "A",
    "comment": "256 × 32 = 8192 → ровно 1 кластер. Ошибка: выбрать B."
  },
  {
    "text": "Кластер = 16384 байт. Файл = 16383 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["0", "1", "2", "3"],
    "correct": "B",
    "comment": "16383 < 16384 → 1 кластер. Ошибка: выбрать A."
  },
  {
    "text": "Файл = 9000 байт, кластер = 4096 байт. Сколько байт занято?",
    "type": "choice",
    "options": ["9000", "8192", "12288", "16384"],
    "correct": "C",
    "comment": "9000 / 4096 ≈ 2.19 → 3 кластера = 3 × 4096 = 12288 байт. Ошибка: выбрать B (2 кластера = 8192 < 9000 — недостаточно)."
  },
  {
    "text": "Запись = 10 байт, записей = 1000. Кластер = 1024 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["9", "10", "11", "12"],
    "correct": "B",
    "comment": "1000 × 10 = 10 000 байт. 10 000 / 1024 ≈ 9.76 → 10 кластеров. Ошибка: выбрать A."
  },
  {
    "text": "Кластер = 4096 байт. Файл = 4097 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["1", "2", "3", "4"],
    "correct": "B",
    "comment": "4097 > 4096 → 2 кластера. Ошибка: выбрать A."
  },
  {
    "text": "Файл = 24 576 байт, кластер = 4096 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["4", "5", "6", "7"],
    "correct": "C",
    "comment": "24 576 / 4096 = 6. Ошибка: выбрать B."
  },
  {
    "text": "Запись = 50 байт, записей = 200. Кластер = 16384 байт. Сколько байт занято?",
    "type": "choice",
    "options": ["10000", "16384", "32768", "8192"],
    "correct": "B",
    "comment": "50 × 200 = 10 000 < 16384 → 1 кластер = 16384 байт. Ошибка: выбрать A."
  },
  {
    "text": "Кластер = 8192 байт. Файл = 24 577 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["3", "4", "5", "6"],
    "correct": "B",
    "comment": "24 577 / 8192 ≈ 3.0001 → 4 кластера. Ошибка: выбрать A."
  },
  {
    "text": "Файл = 512 байт, кластер = 512 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["0", "1", "2", "3"],
    "correct": "B",
    "comment": "Точный размер → 1 кластер. Ошибка: выбрать A."
  },
  {
    "text": "Запись = 1024 байт, записей = 8. Кластер = 8192 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["1", "2", "3", "4"],
    "correct": "A",
    "comment": "1024 × 8 = 8192 → 1 кластер. Ошибка: выбрать B."
  },
  {
    "text": "Кластер = 1024 байт. Файл = 2048 байт. Сколько байт занято?",
    "type": "choice",
    "options": ["2048", "1024", "3072", "4096"],
    "correct": "A",
    "comment": "2048 / 1024 = 2 → 2 кластера = 2048 байт. Ошибка: выбрать B."
  },
  {
    "text": "Файл = 100 байт, кластер = 4096 байт. Сколько байт занято?",
    "type": "choice",
    "options": ["100", "4096", "8192", "2048"],
    "correct": "B",
    "comment": "Даже 100 байт → 1 кластер = 4096 байт. Ошибка: выбрать A."
  },
  {
    "text": "Запись = 2048 байт, записей = 4. Кластер = 8192 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["1", "2", "3", "4"],
    "correct": "A",
    "comment": "2048 × 4 = 8192 → 1 кластер. Ошибка: выбрать B."
  },
  {
    "text": "Кластер = 2048 байт. Файл = 1 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["0", "1", "2", "3"],
    "correct": "B",
    "comment": "Любой ненулевой размер → минимум 1 кластер. Ошибка: выбрать A."
  },
  {
    "text": "Файл = 16 385 байт, кластер = 16384 байт. Сколько байт занято?",
    "type": "choice",
    "options": ["16385", "16384", "32768", "49152"],
    "correct": "C",
    "comment": "16385 > 16384 → 2 кластера = 2 × 16384 = 32768 байт. Ошибка: выбрать A или B."
  },
  {
    "text": "Файл = 7000 байт, кластер = 4096 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["1", "2", "3", "4"],
    "correct": "B",
    "comment": "7000 < 8192 (2 кластера) → 2 кластера. Ошибка: выбрать C."
  },
  {
    "text": "Запись = 150 байт, записей = 50. Кластер = 8192 байт. Потери?",
    "type": "choice",
    "options": ["692", "700", "8192", "0"],
    "correct": "A",
    "comment": "150 × 50 = 7500. 8192 – 7500 = 692 байт. Ошибка: выбрать B."
  },
  {
    "text": "Кластер = 32768 байт. Файл = 32769 байт. Сколько кластеров?",
    "type": "choice",
    "options": ["1", "2", "3", "4"],
    "correct": "B",
    "comment": "32769 > 32768 → 2 кластера. Ошибка: выбрать A."
  },
  {
    "text": "Файл = 12 288 байт, кластер = 4096 байт. Сколько байт занято?",
    "type": "choice",
    "options": ["12288", "8192", "16384", "20480"],
    "correct": "A",
    "comment": "12288 / 4096 = 3 → 3 кластера = 12288 байт. Ошибка: выбрать C."
  },
  {
    "text": "Запись = 400 байт, записей = 10. Кластер = 4096 байт. Потери?",
    "type": "choice",
    "options": ["96", "100", "4096", "0"],
    "correct": "A",
    "comment": "400 × 10 = 4000. 4096 – 4000 = 96 байт. Ошибка: выбрать B."
  }
],

  "type_06": [
  {
    "text": "На каком этапе JPEG происходит основная потеря качества?",
    "type": "choice",
    "options": ["Преобразование RGB → YCbCr", "Дискретное косинусное преобразование (DCT)", "Квантование коэффициентов DCT", "Кодирование Хаффмана"],
    "correct": "C",
    "comment": "Квантование — единственный необратимый этап. Коэффициенты DCT делятся на значения из матрицы квантования и округляются до целых → теряется информация. Ошибка: выбрать B (DCT), но DCT — обратимое математическое преобразование."
  },
  {
    "text": "Какой этап общий для JPEG и MPEG?",
    "type": "choice",
    "options": ["Использование I-кадров", "Межкадровое предсказание", "Дискретное косинусное преобразование (DCT)", "Вектор движения"],
    "correct": "C",
    "comment": "И JPEG (изображения), и MPEG (видео) используют DCT для преобразования блоков пикселей в частотную область. Ошибка: выбрать A или B — это относится только к видео (MPEG)."
  },
  {
    "text": "Что такое зигзаг-сканирование в JPEG?",
    "type": "choice",
    "options": ["Преобразование цветового пространства", "Упорядочивание коэффициентов DCT от низких к высоким частотам", "Сжатие без потерь", "Удаление высокочастотных компонент"],
    "correct": "B",
    "comment": "Зигзаг-сканирование обходит матрицу 8×8 по диагонали, начиная с верхнего левого угла (низкие частоты), чтобы группировать нули в конце последовательности — это повышает эффективность RLE и Хаффмана. Ошибка: выбрать D — удаление происходит на этапе квантования."
  },
  {
    "text": "Какой тип кадра в MPEG не использует информацию из других кадров?",
    "type": "choice",
    "options": ["I-кадр", "P-кадр", "B-кадр", "Все используют"],
    "correct": "A",
    "comment": "I-кадр (Intra-coded) — это полное изображение, сжатое как JPEG. Он не зависит от других кадров и используется для случайного доступа. Ошибка: выбрать B или C — они используют предсказание."
  },
  {
    "text": "Зачем в JPEG используется субдискретизация цветности (chroma subsampling)?",
    "type": "choice",
    "options": ["Потому что человеческий глаз менее чувствителен к цвету, чем к яркости", "Чтобы ускорить DCT", "Для уменьшения размера файла без потерь", "Чтобы избежать артефактов при квантовании"],
    "correct": "A",
    "comment": "В формате YCbCr канал яркости (Y) сохраняется полностью, а цветовые каналы (Cb, Cr) могут быть уменьшены (например, 4:2:0). Это с потерями, но визуально почти незаметно. Ошибка: выбрать C — субдискретизация всегда с потерями."
  },
  {
    "text": "Что делает кодирование Хаффмана в JPEG?",
    "type": "choice",
    "options": ["Удаляет высокочастотные компоненты", "Группирует нули", "Сжимает данные без потерь на основе частоты символов", "Преобразует пиксели в частотную область"],
    "correct": "C",
    "comment": "Хаффман — без потерь. Часто встречающиеся символы кодируются короткими битовыми последовательностями, редкие — длинными. Ошибка: выбрать A или D — это этапы DCT и квантования."
  },
  {
    "text": "Какой этап MPEG отсутствует в JPEG?",
    "type": "choice",
    "options": ["DCT", "Квантование", "Компенсация движения", "Хаффман-кодирование"],
    "correct": "C",
    "comment": "Компенсация движения (motion compensation) использует векторы движения для предсказания содержимого P- и B-кадров на основе других кадров. JPEG работает с одним изображением — движение не применимо. Ошибка: выбрать A — DCT есть в обоих."
  },
  {
    "text": "Что означает \"4:2:0\" в контексте видеосжатия?",
    "type": "choice",
    "options": ["На каждые 4 пикселя яркости приходится 2 пикселя Cb и 0 Cr", "Цветовая информация уменьшена вдвое по горизонтали и вертикали", "Используются 4 канала вместо 3", "Соотношение сторон 4:2:0"],
    "correct": "B",
    "comment": "В 4:2:0 сэмплы Cb и Cr берутся через один пиксель по горизонтали и через одну строку по вертикали → объём цветовой информации уменьшается в 4 раза. Ошибка: выбрать A — Cr тоже присутствует, просто реже."
  },
  {
    "text": "Почему квантование вызывает \"блочные артефакты\" в JPEG?",
    "type": "choice",
    "options": ["Потому что DCT применяется к блокам 8×8", "Потому что высокочастотные коэффициенты обнуляются", "Из-за ошибок в Хаффман-кодировании", "Из-за субдискретизации цвета"],
    "correct": "B",
    "comment": "При сильном квантовании высокочастотные коэффициенты становятся нулями → при обратном DCT границы между блоками 8×8 становятся заметными. Ошибка: выбрать A — блоки есть всегда, но артефакты возникают из-за потери информации при квантовании."
  },
  {
    "text": "Какой кадр в MPEG обеспечивает сжатие за счёт предсказания от предыдущего кадра?",
    "type": "choice",
    "options": ["I-кадр", "P-кадр", "B-кадр", "Все кадры"],
    "correct": "B",
    "comment": "P-кадр (Predictive) использует только предыдущий I- или P-кадр для предсказания. B-кадр использует и предыдущий, и следующий. Ошибка: выбрать C — B-кадр использует два направления."
  },
  {
    "text": "Что такое RLE (Run-Length Encoding) в JPEG?",
    "type": "choice",
    "options": ["Кодирование цвета", "Группировка последовательных нулей в один символ", "Преобразование в YCbCr", "Удаление шума"],
    "correct": "B",
    "comment": "После зигзаг-сканирования часто возникают длинные последовательности нулей. RLE заменяет их на пару (длина, значение), что сокращает объём данных перед Хаффманом. Ошибка: выбрать A — RLE работает с коэффициентами DCT, а не с цветом."
  },
  {
    "text": "Может ли JPEG сжимать изображение без потерь?",
    "type": "choice",
    "options": ["Да, всегда", "Нет, никогда", "Только если отключить квантование", "Только в чёрно-белом режиме"],
    "correct": "C",
    "comment": "Стандарт JPEG поддерживает режим без потерь, где DCT заменяется на предсказательное кодирование, и квантование не применяется. Но обычный JPEG — всегда с потерями. Ошибка: выбрать B — технически возможен без потерь, но редко используется."
  },
  {
    "text": "Какой этап в MPEG самый сложный вычислительно?",
    "type": "choice",
    "options": ["DCT", "Поиск векторов движения", "Квантование", "Хаффман-кодирование"],
    "correct": "B",
    "comment": "Поиск векторов движения требует сравнения блоков с множеством позиций в соседних кадрах — это наиболее ресурсоёмкая операция. Ошибка: выбрать A — DCT быстрее благодаря FFT-подобным алгоритмам."
  },
  {
    "text": "Что происходит на этапе \"цветовое преобразование\" в JPEG?",
    "type": "choice",
    "options": ["Изображение переводится из RGB в YCbCr", "Удаляются цвета, невидимые человеку", "Применяется фильтр Гаусса", "Выравниваются гистограммы"],
    "correct": "A",
    "comment": "RGB → YCbCr позволяет отделить яркость (Y) от цвета (Cb, Cr), что критично для субдискретизации. Ошибка: выбрать B — удаление происходит позже, при квантовании."
  },
  {
    "text": "Какой кадр в MPEG нельзя использовать для декодирования других кадров?",
    "type": "choice",
    "options": ["I-кадр", "P-кадр", "B-кадр", "Все можно"],
    "correct": "C",
    "comment": "B-кадры не используются как опорные для других кадров, потому что они зависят от будущих кадров. Это позволяет повысить сжатие, но усложняет редактирование. Ошибка: выбрать B — P-кадры могут быть опорными."
  },
  {
    "text": "Почему в JPEG блоки имеют размер 8×8?",
    "type": "choice",
    "options": ["Потому что 8 — степень двойки", "Оптимальный баланс между сжатием и артефактами", "Из-за ограничений DCT", "Все вышеперечисленное"],
    "correct": "D",
    "comment": "Размер 8×8 выбран исторически: он даёт хорошее разрешение по частоте, легко обрабатывается, и артефакты не слишком заметны. Ошибка: выбрать только один пункт — на самом деле все факторы важны."
  },
  {
    "text": "Что такое \"GOP\" в MPEG?",
    "type": "choice",
    "options": ["Группа пикселей", "Группа кадров (Group of Pictures)", "Глобальная опорная точка", "Графический объектный протокол"],
    "correct": "B",
    "comment": "GOP — это последовательность кадров от одного I-кадра до следующего. Например: IBBPBBPBB. Ошибка: выбрать A — термин не используется."
  },
  {
    "text": "Какой этап JPEG можно отключить для получения сжатия без потерь?",
    "type": "choice",
    "options": ["DCT", "Квантование", "Зигзаг-сканирование", "Хаффман"],
    "correct": "B",
    "comment": "Если матрица квантования состоит из единиц, то квантование не теряет информацию. Но стандартный JPEG всё равно считается с потерями. Ошибка: выбрать A — DCT без квантования теоретически обратим, но на практике используется другой метод."
  },
  {
    "text": "Что такое \"motion estimation\" в MPEG?",
    "type": "choice",
    "options": ["Оценка скорости движения камеры", "Поиск наилучшего вектора движения для блока", "Удаление дрожания", "Интерполяция кадров"],
    "correct": "B",
    "comment": "Motion estimation — это процесс поиска блока в опорном кадре, наиболее похожего на текущий. Результат — вектор движения. Ошибка: выбрать A — это задача стабилизации, а не сжатия."
  },
  {
    "text": "Какой формат использует только I-кадры?",
    "type": "choice",
    "options": ["MPEG-1", "MJPEG", "H.264", "AV1"],
    "correct": "B",
    "comment": "MJPEG (Motion JPEG) — это последовательность JPEG-изображений. Каждый кадр сжат независимо → только I-кадры. Ошибка: выбрать A — MPEG-1 использует P- и B-кадры."
  },
  {
    "text": "Что уменьшает субдискретизация 4:2:2 по сравнению с 4:4:4?",
    "type": "choice",
    "options": ["Объём цветовой информации в 2 раза", "В 3 раза", "В 4 раза", "Не уменьшает"],
    "correct": "A",
    "comment": "4:2:2 — цвет сэмплируется через один пиксель по горизонтали, но на каждой строке. Объём Cb/Cr уменьшается в 2 раза. Ошибка: выбрать C — это для 4:2:0."
  },
  {
    "text": "Какой этап в JPEG не является обязательным?",
    "type": "choice",
    "options": ["RGB → YCbCr", "DCT", "Квантование", "Хаффман"],
    "correct": "A",
    "comment": "Для чёрно-белых изображений преобразование цвета не нужно — можно работать напрямую с яркостью. Ошибка: выбрать C — квантование обязательно в базовом JPEG."
  },
  {
    "text": "Что такое \"intra prediction\" в современных кодеках (H.264+)?",
    "type": "choice",
    "options": ["Предсказание на основе соседних блоков в том же кадре", "Предсказание от предыдущего кадра", "Удаление шума внутри кадра", "Интерполяция недостающих пикселей"],
    "correct": "A",
    "comment": "Intra prediction использует уже закодированные соседние блоки внутри I-кадра для предсказания текущего — это улучшает сжатие даже без межкадрового анализа. Ошибка: выбрать B — это inter prediction."
  },
  {
    "text": "Почему B-кадры дают лучшее сжатие, чем P-кадры?",
    "type": "choice",
    "options": ["Потому что они используют два опорных кадра", "Потому что они меньше по размеру", "Потому что они не хранятся на диске", "Потому что они чёрно-белые"],
    "correct": "A",
    "comment": "B-кадры могут использовать и предыдущий, и следующий опорные кадры → выше точность предсказания → меньше остаток → лучше сжатие. Ошибка: выбрать B — размер зависит от содержимого."
  },
  {
    "text": "Какой этап JPEG отвечает за \"размытие\" при высоком сжатии?",
    "type": "choice",
    "options": ["DCT", "Квантование", "Субдискретизация", "Хаффман"],
    "correct": "B",
    "comment": "Сильное квантование обнуляет высокочастотные коэффициенты, отвечающие за резкие переходы → изображение становится \"размытым\". Ошибка: выбрать C — субдискретизация вызывает цветовые артефакты, а не размытие."
  },
  {
    "text": "Что такое \"quantization matrix\" в JPEG?",
    "type": "choice",
    "options": ["Таблица для Хаффман-кодирования", "Матрица весов для деления коэффициентов DCT", "Матрица преобразования цвета", "Таблица зигзаг-сканирования"],
    "correct": "B",
    "comment": "Каждый коэффициент DCT делится на соответствующее значение из матрицы квантования и округляется. Чем больше значение — тем сильнее сжатие и потери. Ошибка: выбрать A — Хаффман использует отдельные таблицы."
  },
  {
    "text": "Какой стандарт видеосжатия впервые ввёл B-кадры?",
    "type": "choice",
    "options": ["MPEG-1", "MPEG-2", "H.261", "JPEG"],
    "correct": "A",
    "comment": "MPEG-1 (1993) ввёл три типа кадров: I, P, B. H.261 использовал только I и P. Ошибка: выбрать C — H.261 не имеет B-кадров."
  },
  {
    "text": "Что происходит, если применить JPEG к уже сжатому JPEG-изображению?",
    "type": "choice",
    "options": ["Качество не изменится", "Потери накапливаются", "Файл станет меньше", "Произойдёт сжатие без потерь"],
    "correct": "B",
    "comment": "Каждое повторное сжатие с потерями удаляет дополнительную информацию → артефакты усиливаются. Ошибка: выбрать C — файл может даже увеличиться из-за новых артефактов."
  },
  {
    "text": "Какой цветовой компонент в YCbCr не подвергается субдискретизации?",
    "type": "choice",
    "options": ["Y", "Cb", "Cr", "Все подвергаются"],
    "correct": "A",
    "comment": "Y (яркость) сохраняется в полном разрешении, потому что человеческий глаз чувствителен к деталям яркости. Ошибка: выбрать D."
  },
  {
    "text": "Что такое \"baseline JPEG\"?",
    "type": "choice",
    "options": ["Версия JPEG с поддержкой прогрессивного отображения", "Самый простой и распространённый режим JPEG", "JPEG без потерь", "JPEG с арифметическим кодированием"],
    "correct": "B",
    "comment": "Baseline JPEG — это основной режим сжатия, определённый в стандарте JPEG. Он не поддерживает прогрессивное отображение (это расширение), арифметическое кодирование или сжатие без потерь. Baseline JPEG поддерживается абсолютно всеми устройствами и программами, поэтому является де-факто стандартом. Ошибка: выбрать A — прогрессивный JPEG — это расширение baseline."
  },
  {
    "text": "Какой этап JPEG отвечает за \"эффект водяной краски\" при сильном сжатии?",
    "type": "choice",
    "options": ["DCT", "Квантование", "Субдискретизация цвета", "Хаффман"],
    "correct": "C",
    "comment": "\"Эффект водяной краски\" (color bleeding) — это когда цвета \"растекаются\" за пределы объектов, например, красный фон окрашивает края белого текста. Это происходит из-за субдискретизации цвета: каналы Cb/Cr имеют меньшее разрешение, поэтому при восстановлении цвет усредняется на блоке 2×2 или 4×4 пикселей. Этот артефакт не связан с квантованием (который вызывает блочность и размытие), а именно с потерей пространственного разрешения цвета. Ошибка: выбрать B — квантование влияет на яркость и текстуру, но не на цветовую локализацию."
  },
  {
    "text": "Что такое \"DC coefficient\" в JPEG?",
    "type": "choice",
    "options": ["Коэффициент, отвечающий за постоянную составляющую блока", "Коэффициент, отвечающий за высокие частоты", "Разность между кадрами", "Коэффициент дискретизации цвета"],
    "correct": "A",
    "comment": "После DCT матрица 8×8 содержит 64 коэффициента. DC coefficient — это верхний левый элемент (0,0), который представляет среднюю яркость всего блока (постоянная составляющая). Все остальные 63 коэффициента — AC coefficients (переменные составляющие), отвечающие за детали. DC-коэффициенты соседних блоков сильно коррелированы, поэтому в JPEG они кодируются разностно: сохраняется разность между текущим DC и предыдущим. Ошибка: выбрать B — высокие частоты — это правый нижний угол AC-коэффициентов."
  },
  {
    "text": "Какой стандарт использует \"GOP closed\"?",
    "type": "choice",
    "options": ["MPEG-1", "MPEG-2", "H.264", "Все вышеперечисленные"],
    "correct": "D",
    "comment": "\"Closed GOP\" — это структура, в которой B-кадры не ссылаются на кадры из следующего GOP. Это означает, что каждый GOP полностью независим и может быть декодирован отдельно. Такая структура используется во всех основных стандартах (MPEG-1/2/4, H.264, HEVC) при необходимости произвольного доступа (например, в вещании, потоковом видео). Open GOP позволяет B-кадрам ссылаться на I-кадр следующего GOP, что даёт чуть лучшее сжатие, но усложняет редактирование и перемотку. Ошибка: выбрать только один стандарт — closed GOP — общая концепция."
  },
  {
    "text": "Почему в JPEG не используется арифметическое кодирование по умолчанию?",
    "type": "choice",
    "options": ["Оно медленнее", "Оно было запатентовано", "Оно даёт худшее сжатие", "Оно не поддерживает цвет"],
    "correct": "B",
    "comment": "Арифметическое кодирование действительно даёт на 5–10% лучшее сжатие, чем Хаффман, и поддерживается стандартом JPEG. Однако в 1990-х годах оно было запатентовано несколькими компаниями (IBM, AT&T, Mitsubishi), что сделало его использование коммерчески рискованным. Поэтому подавляющее большинство реализаций (включая все веб-браузеры) используют только Хаффман-кодирование. Патенты истекли в 2010-х, но к тому времени Хаффман уже стал стандартом де-факто. Ошибка: выбрать A — скорость не была главной проблемой."
  },
  {
    "text": "Что такое \"macroblock\" в MPEG?",
    "type": "choice",
    "options": ["Блок 8×8 пикселей", "Блок 16×16 пикселей, состоящий из четырёх блоков яркости и двух цветовых", "Весь кадр", "Группа кадров"],
    "correct": "B",
    "comment": "Macroblock — это основная единица обработки в MPEG-1/2/4. Он имеет размер 16×16 пикселей в яркости (Y) и включает: 4 блока Y по 8×8, 1 блок Cb 8×8, 1 блок Cr 8×8 (при субдискретизации 4:2:0). Macroblock используется для поиска движения, компенсации движения и DCT. В H.264/HEVC понятие macroblock заменено на CTU (Coding Tree Unit), но суть аналогична. Ошибка: выбрать A — 8×8 — это block, а не macroblock."
  },
  {
    "text": "Какой артефакт возникает при слишком сильной субдискретизации цвета?",
    "type": "choice",
    "options": ["Блочность", "Цветовые \"ступеньки\" на градиентах", "Размытие текстуры", "Шум"],
    "correct": "B",
    "comment": "При субдискретизации цвета (особенно 4:2:0) цветовые компоненты имеют низкое разрешение. На плавных цветовых градиентах (например, небо) это приводит к появлению видимых \"ступенек\" или полос. Это происходит потому, что цвет усредняется на блоках 2×2 или больше, и мелкие вариации теряются. Блочность (A) связана с квантованием DCT, размытие (C) — тоже с квантованием, шум (D) — с недостаточным битрейтом. Ошибка: выбрать A — блочность — это артефакт яркости, а не цвета."
  },
  {
    "text": "Что делает \"progressive JPEG\"?",
    "type": "choice",
    "options": ["Показывает изображение постепенно, от низкого к высокому разрешению", "Сжимает изображение без потерь", "Использует только I-кадры", "Уменьшает цветовую глубину"],
    "correct": "A",
    "comment": "Progressive JPEG — это режим, при котором изображение сохраняется не построчно (как baseline), а по частотным компонентам. Сначала загружаются грубые коэффициенты (низкие частоты), и пользователь видит размытую, но узнаваемую картинку. По мере загрузки добавляются детали (высокие частоты), и качество улучшается. Это улучшает UX при медленном интернете. Progressive JPEG использует те же этапы (DCT, квантование), но данные организованы иначе. Ошибка: выбрать B — progressive JPEG всё ещё с потерями."
  },
  {
    "text": "Какой этап MPEG уменьшает временную избыточность?",
    "type": "choice",
    "options": ["DCT", "Квантование", "Межкадровое предсказание", "Хаффман"],
    "correct": "C",
    "comment": "Временная избыточность — это схожесть между соседними кадрами видео. Межкадровое предсказание (через P- и B-кадры) устраняет эту избыточность, кодируя только изменения. Пространственная избыточность (сходство соседних пикселей в одном кадре) устраняется DCT и квантованием. Таким образом, MPEG использует два уровня сжатия: пространственный (как JPEG) и временной (уникальный для видео). Ошибка: выбрать A — DCT работает только в пределах одного кадра."
  },
  {
    "text": "Что такое \"chroma\" в YCbCr?",
    "type": "choice",
    "options": ["Яркость", "Цветность (оттенок и насыщенность)", "Контраст", "Резкость"],
    "correct": "B",
    "comment": "В цветовом пространстве YCbCr: Y = luminance (яркость), Cb = blue-difference chroma (отклонение синего от яркости), Cr = red-difference chroma (отклонение красного от яркости). Совместно Cb и Cr определяют цветность — то есть оттенок и насыщенность, независимо от яркости. Это позволяет обрабатывать яркость и цвет отдельно, что критично для сжатия. Ошибка: выбрать A — Y — это яркость."
  },
  {
    "text": "Почему B-кадры увеличивают задержку при потоковой передаче?",
    "type": "choice",
    "options": ["Потому что они крупнее", "Потому что для их декодирования нужен будущий кадр", "Потому что они шифруются", "Потому что они сжимаются дольше"],
    "correct": "B",
    "comment": "B-кадры зависят от следующего опорного кадра (I или P), который по времени идёт позже. Поэтому декодер должен буферизировать несколько кадров вперёд, чтобы иметь доступ к будущему опорному кадру. Это создаёт задержку (latency), которая критична для видеозвонков, игр, live-трансляций. Именно поэтому в таких приложениях часто используют только I- и P-кадры (например, Skype, Zoom). Ошибка: выбрать A — B-кадры обычно меньше P-кадров."
  },
  {
    "text": "Какой стандарт ввёл \"арифметическое кодирование\" в видеосжатие?",
    "type": "choice",
    "options": ["MPEG-1", "MPEG-2", "H.263", "JPEG"],
    "correct": "D",
    "comment": "Хотя вопрос про видеосжатие, арифметическое кодирование впервые было введено в стандарт JPEG (1992) как альтернатива Хаффману. В видео стандартах оно появилось позже: H.263 (1996) поддерживал его опционально, а H.264 использует CABAC (Context-Adaptive Binary Arithmetic Coding). Но JPEG был первым. Ошибка: выбрать C — H.263 не был первым."
  },
  {
    "text": "Что такое \"bitrate\" в контексте MPEG?",
    "type": "choice",
    "options": ["Количество бит на пиксель", "Скорость потока данных (бит/сек)", "Глубина цвета", "Частота кадров"],
    "correct": "B",
    "comment": "Bitrate — это среднее количество бит в секунду, выделяемое на видео (и аудио). Например, 5 Мбит/с. Bitrate напрямую влияет на качество: выше bitrate → меньше квантование → меньше артефактов. В MPEG bitrate может быть постоянным (CBR) или переменным (VBR). CBR проще для потоковой передачи, VBR эффективнее для хранения. Ошибка: выбрать A — это bit per pixel, а не bitrate."
  },
  {
    "text": "Какой артефакт характерен для низкого битрейта в MPEG?",
    "type": "choice",
    "options": ["\"Плавающие\" блоки при движении", "Цветовые ступеньки", "Размытие", "Все вышеперечисленное"],
    "correct": "D",
    "comment": "При низком битрейте кодер вынужден: Использовать сильное квантование → блочность, размытие, Увеличивать GOP → ошибки распространяются дольше, Снижать частоту I-кадров → при ошибках изображение \"плывёт\", пока не придёт следующий I-кадр, Применять агрессивную субдискретизацию → цветовые артефакты. Поэтому все перечисленные артефакты характерны для низкокачественного видео. Ошибка: выбрать только один — на практике они комбинируются."
  },
  {
    "text": "Что такое \"I-frame only\" кодирование?",
    "type": "choice",
    "options": ["Кодирование только чёрно-белых изображений", "Использование только I-кадров", "Сжатие без потерь", "Кодирование с фиксированным битрейтом"],
    "correct": "B",
    "comment": "\"I-frame only\" — это режим, при котором все кадры являются I-кадрами (как в MJPEG). Преимущества: мгновенный доступ к любому кадру, простота редактирования (можно вырезать любой фрагмент), низкая задержка (не нужно буферизировать). Недостаток: низкая эффективность сжатия (в 3–10 раз хуже, чем с P/B-кадрами). Используется в видеонаблюдении, медицинской визуализации, где важна целостность каждого кадра. Ошибка: выбрать C — I-frame only всё ещё с потерями."
  },
  {
    "text": "Какой этап JPEG можно считать \"обратимым\"?",
    "type": "choice",
    "options": ["Квантование", "DCT", "Субдискретизация", "Все необратимы"],
    "correct": "B",
    "comment": "DCT (Discrete Cosine Transform) — это ортогональное преобразование, аналогичное повороту вектора в пространстве. Оно математически обратимо без потерь, если коэффициенты хранятся с достаточной точностью. Потери возникают только на этапе квантования (округление до целых) и субдискретизации (уменьшение разрешения цвета). В теории, если пропустить квантование и субдискретизацию, DCT + обратный DCT восстановит исходное изображение точно. Ошибка: выбрать D — DCT сам по себе обратим."
  },
  {
    "text": "Что такое \"motion vector\" в MPEG?",
    "type": "choice",
    "options": ["Вектор скорости движения камеры", "Смещение блока относительно опорного кадра", "Направление движения объекта", "Угловая скорость поворота"],
    "correct": "B",
    "comment": "Motion vector — это пара чисел (dx, dy), указывающая, на сколько пикселей смещён блок в текущем кадре относительно его положения в опорном кадре. Например, (5, -2) означает сдвиг на 5 пикселей вправо и 2 вверх. Motion vectors передаются в видеопотоке и используются декодером для motion compensation — копирования блока из опорного кадра в текущую позицию. Это позволяет не хранить сам блок, а только разность (остаток), что сильно экономит место. Ошибка: выбрать A — motion vector относится к блокам, а не к камере."
  },
  {
    "text": "Какой стандарт поддерживает \"lossless JPEG\"?",
    "type": "choice",
    "options": ["Только JPEG", "JPEG и JPEG 2000", "Только JPEG 2000", "Ни один"],
    "correct": "B",
    "comment": "JPEG (ISO/IEC 10918-1) включает режим без потерь на основе предсказания (разность с соседом) и арифметического кодирования. JPEG 2000 (ISO/IEC 15444-1) использует вейвлет-преобразование и также поддерживает без потерь (путём пропуска квантования). Оба стандарта формально допускают lossless, но на практике JPEG без потерь почти не используется, а JPEG 2000 применяется в медицине, архивировании. Ошибка: выбрать A — JPEG 2000 тоже поддерживает."
  },
  {
    "text": "Что такое \"zigzag order\" в JPEG?",
    "type": "choice",
    "options": ["Порядок обхода пикселей в блоке 8×8", "Порядок обхода коэффициентов DCT от низких к высоким частотам", "Порядок кадров в GOP", "Порядок цветовых компонент"],
    "correct": "B",
    "comment": "Zigzag order — это конкретная последовательность индексов для обхода матрицы 8×8: (0,0) → (0,1) → (1,0) → (2,0) → (1,1) → (0,2) → (0,3) → (1,2) → ... → (7,7). Этот порядок следует по диагоналям, начиная с низкочастотного угла, и обеспечивает, что ненулевые коэффициенты группируются в начале одномерного массива, а нули — в конце. Это критично для эффективности RLE. Ошибка: выбрать A — пиксели обходятся построчно, а не зигзагом."
  },
  {
    "text": "Какой этап MPEG уменьшает пространственную избыточность?",
    "type": "choice",
    "options": ["Межкадровое предсказание", "DCT и квантование", "Векторы движения", "B-кадры"],
    "correct": "B",
    "comment": "Пространственная избыточность — это корреляция между соседними пикселями внутри одного кадра. Она устраняется теми же методами, что и в JPEG: DCT преобразует блок в частотную область, где данные можно эффективно сжать, а квантование удаляет малозначимые (высокочастотные) компоненты. Межкадровое предсказание (A, C, D) работает с временной избыточностью (между кадрами). Ошибка: выбрать A — это временной, а не пространственный метод."
  },
  {
    "text": "Почему JPEG не подходит для изображений с текстом или линиями?",
    "type": "choice",
    "options": ["Потому что он чёрно-белый", "Потому что квантование вызывает артефакты на резких переходах", "Потому что он медленный", "Потому что он не поддерживает прозрачность"],
    "correct": "B",
    "comment": "Изображения с текстом, графикой, логотипами содержат резкие переходы (чёрный текст на белом фоне). Эти переходы соответствуют высоким частотам в DCT. При квантовании высокочастотные коэффициенты обнуляются, что приводит к: ореолам вокруг букв, блочности на краях, искажению формы символов. Для таких изображений лучше использовать PNG (сжатие без потерь) или JPEG 2000 (менее выраженные артефакты). Прозрачность (D) — отдельная проблема, но даже без неё JPEG плохо справляется с текстом. Ошибка: выбрать D — прозрачность не причина артефактов на тексте."
  }
],

  "type_07": [
  {
    "text": "Какая команда очищает экран в Windows CMD?",
    "type": "choice",
    "options": ["clear", "cls", "clean", "reset"],
    "correct": "B",
    "comment": "cls (clear screen) — стандартная команда Windows. clear используется в Linux/macOS и является типичной ошибкой у пользователей, знакомых с обеими системами."
  },
  {
    "text": "Что выведет команда `echo %USERNAME%`?",
    "type": "choice",
    "options": ["Имя компьютера", "Имя текущего пользователя", "Полное имя пользователя в формате DOMAIN\\user", "Ошибку"],
    "correct": "B",
    "comment": "%USERNAME% — системная переменная, содержащая только имя пользователя без домена. Для полного имени используется команда `whoami`, но она не эквивалентна в выводе."
  },
  {
    "text": "Какая команда делает паузу на 2 секунды без вывода сообщения?",
    "type": "choice",
    "options": ["pause 2", "timeout /t 2", "timeout /t 2 >nul", "sleep 2"],
    "correct": "C",
    "comment": "Без `>nul` команда `timeout` выводит «Waiting for 2 seconds...». `sleep` отсутствует в стандартной Windows CMD — она характерна для Unix-систем."
  },
  {
    "text": "Что произойдёт при выполнении команды `del *.tmp`?",
    "type": "choice",
    "options": ["Будет удалён один файл с именем `*.tmp`", "Удаляются все файлы с расширением `.tmp`", "Удалится папка `tmp`", "Команда завершится с ошибкой"],
    "correct": "B",
    "comment": "Символ `*` в Windows CMD является маской, означающей «любая последовательность символов». Таким образом, `*.tmp` соответствует всем файлам, заканчивающимся на `.tmp`. Это стандартный механизм работы с группами файлов."
  },
  {
    "text": "Какая команда покажет IPv4-адрес сетевого адаптера?",
    "type": "choice",
    "options": ["ip addr", "ifconfig", "ipconfig", "netstat -i"],
    "correct": "C",
    "comment": "`ipconfig` — встроенная команда Windows для отображения сетевой конфигурации. Команды `ip addr` и `ifconfig` относятся к Linux, а `netstat -i` показывает статистику интерфейсов, но не IP-адрес напрямую."
  },
  {
    "text": "Что делает команда `copy report.txt backup\\`?",
    "type": "choice",
    "options": ["Перемещает файл `report.txt` в папку `backup`", "Копирует файл `report.txt` в папку `backup`", "Создаёт резервную копию с именем `report.bak`", "Выводит содержимое файла `report.txt`"],
    "correct": "B",
    "comment": "Команда `copy` всегда выполняет копирование, а не перемещение. Для перемещения используется команда `move`. Обратный слэш `\\` после имени папки указывает, что `backup` — это каталог, а не имя файла."
  },
  {
    "text": "Какие из следующих команд эквивалентны и создают новую папку?",
    "type": "choice",
    "options": ["mkdir и md", "newdir и create", "dir /new и folder", "Только mkdir"],
    "correct": "A",
    "comment": "В Windows CMD команды `mkdir` и `md` являются полными синонимами и обе создают новый каталог. Это историческое наследие MS-DOS, где для удобства были предусмотрены короткие и длинные формы команд."
  },
  {
    "text": "Что выведет команда `cd` без аргументов?",
    "type": "choice",
    "options": ["Ошибку", "Список файлов в текущей директории", "Полный путь к текущей директории", "Корневой каталог диска"],
    "correct": "C",
    "comment": "В Windows команда `cd` без параметров выводит полный путь к текущей рабочей директории. В Unix-системах для этого используется команда `pwd`, что часто вызывает путаницу."
  },
  {
    "text": "Как правильно скрыть стандартный вывод команды в Windows CMD?",
    "type": "choice",
    "options": ["--quiet", ">null", ">nul", "silent"],
    "correct": "C",
    "comment": "В Windows специальное устройство называется `nul` (без буквы \"l\" в конце). Перенаправление вывода с помощью `>nul` подавляет печать результата в консоль. Написание `>null` — распространённая орфографическая ошибка."
  },
  {
    "text": "Что делает флаг `/q` в команде `del /q file.log`?",
    "type": "choice",
    "options": ["Удаляет файл без запроса подтверждения", "Выводит подтверждение удаления", "Перемещает файл в корзину", "Блокирует файл от удаления"],
    "correct": "A",
    "comment": "Флаг `/q` означает «quiet mode» (тихий режим) и отключает интерактивный запрос подтверждения, который появляется при удалении файлов в некоторых версиях Windows. Это особенно важно при написании пакетных скриптов."
  },
  {
    "text": "Какая команда принудительно завершит процесс `notepad.exe`?",
    "type": "choice",
    "options": ["kill notepad.exe", "stop notepad", "taskkill /f /im notepad.exe", "exit notepad"],
    "correct": "C",
    "comment": "`taskkill` — стандартная команда Windows для завершения процессов. Флаг `/f` означает «принудительно», а `/im` указывает, что далее следует имя образа (executable). Команда `kill` отсутствует в CMD."
  },
  {
    "text": "Что выведет команда `time /t`?",
    "type": "choice",
    "options": ["Текущее время с секундами и миллисекундами", "Текущее время в формате ЧЧ:ММ (без секунд)", "Запрос на ввод нового времени", "Время с момента загрузки системы"],
    "correct": "B",
    "comment": "Флаг `/t` заставляет команду `time` вывести только текущее время в кратком формате, без секунд и без запроса на изменение. Без этого флага система предложит ввести новое время."
  },
  {
    "text": "Какие команды могут быть использованы для отображения MAC-адреса сетевого адаптера?",
    "type": "choice",
    "options": ["getmac", "ipconfig /all", "netsh interface show interface", "A и B"],
    "correct": "D",
    "comment": "Команда `getmac` напрямую выводит MAC-адреса. Команда `ipconfig /all` также содержит эту информацию в разделе каждого адаптера. `netsh interface show interface` показывает состояние интерфейсов, но не MAC-адрес. Поэтому правильны A и B."
  },
  {
    "text": "Что делает команда `type nul > empty.txt`?",
    "type": "choice",
    "options": ["Создаёт пустой файл размером 0 байт", "Создаёт файл с одним символом перевода строки", "Выводит содержимое устройства nul", "Удаляет файл empty.txt, если он существует"],
    "correct": "A",
    "comment": "Устройство `nul` в Windows не содержит данных. Перенаправление его «содержимого» в файл создаёт файл нулевой длины. Это отличается от `echo. > file.txt`, который создаёт файл с символом перевода строки (2 байта в Windows)."
  },
  {
    "text": "Какая из перечисленных команд отсутствует в стандартной поставке Windows CMD?",
    "type": "choice",
    "options": ["xcopy", "robocopy", "rsync", "copy"],
    "correct": "C",
    "comment": "`rsync` — это утилита для синхронизации файлов в Unix-подобных системах. Она не входит в состав Windows. `xcopy` и `robocopy` — расширенные команды копирования, доступные в современных версиях Windows. `copy` — базовая команда."
  },
  {
    "text": "Что выведет команда `echo %DATE%` в системе с русской локализацией?",
    "type": "choice",
    "options": ["2026-01-14", "14.0.2026", "14.01.2026", "Jan 14, 2026"],
    "correct": "C",
    "comment": "Формат даты в переменной `%DATE%` зависит от региональных настроек Windows. В русской локали используется формат ДД.ММ.ГГГГ, поэтому результат — `14.01.2026`."
  },
  {
    "text": "Какая команда показывает список всех запущенных процессов?",
    "type": "choice",
    "options": ["ps", "top", "tasklist", "proc"],
    "correct": "C",
    "comment": "`tasklist` — встроенная команда Windows, аналог `ps` в Linux. Остальные варианты либо отсутствуют (`proc`), либо относятся к другим ОС (`ps`, `top`)."
  },
  {
    "text": "Что делает оператор `&` в командной строке Windows?",
    "type": "choice",
    "options": ["Выполняет вторую команду, только если первая завершилась успешно", "Выполняет вторую команду, только если первая завершилась с ошибкой", "Выполняет команды последовательно, независимо от результата", "Объединяет две команды в одну"],
    "correct": "C",
    "comment": "Оператор `&` обеспечивает последовательное выполнение команд, даже если первая завершилась с ошибкой. Для условного выполнения (только при успехе) используется `&&`."
  },
  {
    "text": "Какая команда выводит имя текущего компьютера?",
    "type": "choice",
    "options": ["computername", "hostname", "echo %MACHINE%", "pcname"],
    "correct": "B",
    "comment": "Команда `hostname` доступна в Windows CMD и выводит имя компьютера. Переменная `%COMPUTERNAME%` также содержит это значение, но самой команды `computername` не существует."
  },
  {
    "text": "Что произойдёт при выполнении `rmdir /s /q OldFolder`?",
    "type": "choice",
    "options": ["Папка `OldFolder` будет удалена, если она пуста", "Папка `OldFolder` и всё её содержимое будут удалены без подтверждения", "Будет выведена ошибка, так как флаги неверны", "Папка будет перемещена в корзину"],
    "correct": "B",
    "comment": "Флаг `/s` указывает на рекурсивное удаление (включая все вложенные файлы и папки), а `/q` отключает запрос подтверждения. Это стандартный способ полного удаления каталога в скриптах."
  },
  {
    "text": "Какая команда используется для поиска текста в выводе другой команды?",
    "type": "choice",
    "options": ["grep", "find", "search", "locate"],
    "correct": "B",
    "comment": "В Windows для фильтрации текста используются команды `find` и `findstr`. `grep` — это утилита Unix, отсутствующая в стандартной Windows CMD."
  },
  {
    "text": "Что делает команда `dir /b`?",
    "type": "choice",
    "options": ["Выводит список файлов с подробной информацией", "Выводит только имена файлов и папок без заголовков и итогов", "Сортирует файлы по дате", "Показывает скрытые файлы"],
    "correct": "B",
    "comment": "Флаг `/b` (bare format) упрощает вывод команды `dir` до одного списка имён, что удобно для дальнейшей обработки в скриптах."
  },
  {
    "text": "Какая команда завершает текущий сеанс командной строки?",
    "type": "choice",
    "options": ["quit", "exit", "close", "end"],
    "correct": "B",
    "comment": "`exit` — стандартная команда для выхода из интерпретатора командной строки в Windows, DOS и многих других системах."
  },
  {
    "text": "Что выведет команда `echo %PATH%`?",
    "type": "choice",
    "options": ["Текущую директорию", "Список каталогов, где Windows ищет исполняемые файлы", "Путь к файлу PATH.txt", "Ошибку"],
    "correct": "B",
    "comment": "Переменная `%PATH%` содержит список путей, разделённых точкой с запятой. При запуске команды Windows ищет исполняемый файл в этих каталогах по порядку."
  },
  {
    "text": "Какая команда проверяет сетевую связность с удалённым хостом?",
    "type": "choice",
    "options": ["traceroute", "ping", "netstat", "arp"],
    "correct": "B",
    "comment": "`ping` отправляет ICMP-пакеты и ждёт ответа, что позволяет проверить базовую связность. Это самая простая и часто используемая команда для диагностики сети."
  },
  {
    "text": "Напишите команду, которая очищает экран и выводит текущую дату.",
    "type": "text",
    "correct": "cls & date /t",
    "comment": "Команда `cls` очищает экран, `date /t` выводит дату без запроса на изменение. Оператор `&` обеспечивает последовательное выполнение."
  },
  {
    "text": "Напишите команду, которая выводит имя текущего пользователя и делает паузу на 2 секунды без сообщения.",
    "type": "text",
    "correct": "echo %USERNAME% & timeout /t 2 >nul",
    "comment": "Используется системная переменная и подавление вывода `timeout` через перенаправление в `nul`."
  },
  {
    "text": "Напишите команду, которая показывает IPv4-адрес компьютера и очищает экран.",
    "type": "text",
    "correct": "ipconfig | findstr \"IPv4\" & cls",
    "comment": "Вертикальная черта `|` передаёт вывод `ipconfig` в `findstr`, который фильтрует строки, содержащие \"IPv4\"."
  },
  {
    "text": "Напишите команду, которая создаёт папку `Data` и копирует в неё файл `info.txt`.",
    "type": "text",
    "correct": "mkdir Data & copy info.txt Data\\",
    "comment": "Обратный слэш после `Data` гарантирует, что команда `copy` интерпретирует это как каталог."
  },
  {
    "text": "Напишите команду, которая выводит содержимое файла `readme.txt` и делает паузу на 1 секунду.",
    "type": "text",
    "correct": "type readme.txt & timeout /t 1 >nul",
    "comment": "`type` выводит содержимое текстового файла, `timeout /t 1 >nul` делает короткую тихую паузу."
  },
  {
    "text": "Напишите команду, которая удаляет файл `temp.log` без подтверждения и выводит \"Done\".",
    "type": "text",
    "correct": "del /q temp.log & echo Done",
    "comment": "Флаг `/q` отключает запрос подтверждения, `echo` даёт обратную связь."
  },
  {
    "text": "Напишите команду, которая выводит текущее время и очищает экран.",
    "type": "text",
    "correct": "time /t & cls",
    "comment": "`time /t` выводит время в формате ЧЧ:ММ, `cls` очищает экран."
  },
  {
    "text": "Напишите команду, которая проверяет доступность `yandex.ru` одним пакетом и ничего не выводит.",
    "type": "text",
    "correct": "ping -n 1 yandex.ru >nul",
    "comment": "Флаг `-n 1` ограничивает количество пакетов одним, `>nul` подавляет весь вывод команды."
  },
  {
    "text": "Напишите команду, которая выводит имя компьютера и текущего пользователя.",
    "type": "text",
    "correct": "echo %COMPUTERNAME% %USERNAME%",
    "comment": "Это компактный и надёжный способ. Альтернатива: `hostname & echo %USERNAME%`."
  },
  {
    "text": "Напишите команду, которая создаёт пустой файл `flag.txt`.",
    "type": "text",
    "correct": "type nul > flag.txt",
    "comment": "Это единственный способ создать файл размером ровно 0 байт с помощью встроенных средств CMD."
  },
  {
    "text": "Напишите команду, которая выводит текущий путь и делает паузу на 3 секунды.",
    "type": "text",
    "correct": "cd & timeout /t 3 >nul",
    "comment": "`cd` без аргументов выводит полный путь, `timeout` делает скрытую паузу."
  },
  {
    "text": "Напишите команду, которая копирует `report.doc` в папку `Archive` и выводит \"Saved\".",
    "type": "text",
    "correct": "copy report.doc Archive\\ & echo Saved",
    "comment": "Обратный слэш после `Archive` обязателен для однозначной интерпретации как каталога."
  },
  {
    "text": "Напишите команду, которая завершает процесс `calc.exe` без подтверждения.",
    "type": "text",
    "correct": "taskkill /f /im calc.exe",
    "comment": "`/f` — принудительное завершение, `/im` — указание по имени образа."
  },
  {
    "text": "Напишите команду, которая выводит список файлов в кратком формате и очищает экран.",
    "type": "text",
    "correct": "dir /b & cls",
    "comment": "`/b` даёт только имена файлов, без заголовков и итоговой строки."
  },
  {
    "text": "Напишите команду, которая выводит версию Windows и делает паузу на 2 секунды.",
    "type": "text",
    "correct": "ver & timeout /t 2 >nul",
    "comment": "`ver` выводит строку вида «Microsoft Windows [Version 10.0.19045.1»."
  },
  {
    "text": "Напишите команду, которая удаляет папку `Old` со всем содержимым без подтверждения.",
    "type": "text",
    "correct": "rmdir /s /q Old",
    "comment": "`/s` — рекурсивно, `/q` — без подтверждения."
  },
  {
    "text": "Напишите команду, которая выводит MAC-адрес и очищает экран.",
    "type": "text",
    "correct": "getmac /nh & cls",
    "comment": "`/nh` (no header) убирает заголовок таблицы, оставляя только MAC-адреса."
  },
  {
    "text": "Напишите команду, которая выводит дату и время в одной строке.",
    "type": "text",
    "correct": "echo %DATE% %TIME%",
    "comment": "Использование двух системных переменных в одной команде `echo`."
  },
  {
    "text": "Напишите команду, которая создаёт файл `note.txt` с текстом \"Ready\" и делает паузу на 1 секунду.",
    "type": "text",
    "correct": "echo Ready > note.txt & timeout /t 1 >nul",
    "comment": "`echo` записывает строку в файл, автоматически добавляя перевод строки."
  },
  {
    "text": "Напишите команду, которая выводит IP-шлюз и очищает экран.",
    "type": "text",
    "correct": "ipconfig | findstr \"Default Gateway\" & cls",
    "comment": "Строка \"Default Gateway\" присутствует в выводе `ipconfig` для каждого активного адаптера."
  },
  {
    "text": "Напишите команду, которая выводит имя пользователя в формате `ПК\\имя` и делает паузу на 2 секунды.",
    "type": "text",
    "correct": "whoami & timeout /t 2 >nul",
    "comment": "`whoami` всегда выводит полное имя, включая имя компьютера или домена."
  },
  {
    "text": "Напишите команду, которая копирует все `.txt` файлы в папку `Texts`.",
    "type": "text",
    "correct": "copy *.txt Texts\\",
    "comment": "Маска `*` позволяет копировать несколько файлов одной командой."
  },
  {
    "text": "Напишите команду, которая выводит свободное место на диске C: и делает паузу на 3 секунды.",
    "type": "text",
    "correct": "dir C:\\ | findstr \"bytes free\" & timeout /t 3 >nul",
    "comment": "В выводе `dir C:\\` присутствует строка вида «1234567890 bytes free», которую можно извлечь через `findstr`."
  },
  {
    "text": "Напишите команду, которая создаёт папки `Input` и `Output`.",
    "type": "text",
    "correct": "mkdir Input & mkdir Output",
    "comment": "Две последовательные команды создания каталогов."
  },
  {
    "text": "Напишите команду, которая очищает экран, выводит время и делает паузу на 2 секунды.",
    "type": "text",
    "correct": "cls & time /t & timeout /t 2 >nul",
    "comment": "Три базовые операции, часто используемые вместе для оформления вывода скриптов."
  }
],

  "type_08": [
  {
    "text": "Какой принцип лежит в основе архитектуры фон Неймана?",
    "type": "choice",
    "options": ["Раздельная память для данных и команд", "Единая память для данных и команд", "Параллельное выполнение всех инструкций", "Использование только регистровой памяти"],
    "correct": "B",
    "comment": "Архитектура фон Неймана предполагает, что программа и данные хранятся в одной и той же памяти. Это позволяет программам модифицировать сами себя, но создаёт «узкое горлышко» (фон-неймановское узкое место). Вариант A описывает гарвардскую архитектуру, используемую в микроконтроллерах."
  },
  {
    "text": "Какие компоненты входят в состав классической архитектуры фон Неймана?",
    "type": "choice",
    "options": ["ЦП, память, устройства ввода/вывода, шина", "Только ЦП и память", "Процессор, кэш, регистры, видеокарта", "Ядро, драйверы, ОЗУ, жёсткий диск"],
    "correct": "A",
    "comment": "Основные блоки: центральный процессор (ЦП), оперативная память, устройства ввода/вывода и соединяющая их шина (для передачи адресов, данных и управляющих сигналов). Кэш и регистры — часть ЦП, но не отдельные блоки архитектуры."
  },
  {
    "text": "Что такое «фон-неймановское узкое место»?",
    "type": "choice",
    "options": ["Медленная работа устройств ввода/вывода", "Ограничение пропускной способности между ЦП и памятью", "Невозможность параллельного выполнения команд", "Ограниченный размер кэш-памяти"],
    "correct": "B",
    "comment": "Поскольку команды и данные передаются по одной шине, ЦП вынужден чередовать обращения к памяти, что ограничивает производительность. Это фундаментальное ограничение архитектуры фон Неймана."
  },
  {
    "text": "Какая архитектура использует раздельную память для команд и данных?",
    "type": "choice",
    "options": ["Архитектура фон Неймана", "Гарвардская архитектура", "Симметричная мультипроцессорная", "Микроядерная"],
    "correct": "B",
    "comment": "Гарвардская архитектура имеет две независимые шины и две памяти — для команд и данных. Это позволяет одновременно выбирать команду и читать данные, повышая скорость. Используется в DSP и микроконтроллерах (например, AVR)."
  },
  {
    "text": "Какой блок процессора отвечает за выполнение арифметических и логических операций?",
    "type": "choice",
    "options": ["Блок управления (CU)", "Арифметико-логическое устройство (ALU)", "Регистры", "Кэш-память"],
    "correct": "B",
    "comment": "ALU (Arithmetic Logic Unit) выполняет операции сложения, вычитания, AND, OR, сдвиги и т.д. Блок управления (CU) декодирует команды и управляет потоком данных."
  },
  {
    "text": "Что такое регистр PC (Program Counter)?",
    "type": "choice",
    "options": ["Регистр, хранящий результат последней операции", "Регистр, указывающий на адрес следующей команды", "Регистр флагов состояния", "Регистр для временного хранения данных"],
    "correct": "B",
    "comment": "Program Counter (счётчик команд) содержит адрес следующей выполняемой инструкции. После выполнения команды он обычно увеличивается на длину команды (или загружается новым адресом при переходе)."
  },
  {
    "text": "Какие из перечисленных компонентов находятся на кристалле современного CPU?",
    "type": "choice",
    "options": ["ALU, CU, регистры, кэш L1", "Оперативная память (RAM)", "Жёсткий диск", "Видеокарта"],
    "correct": "A",
    "comment": "Современные процессоры интегрируют ALU, CU, регистры и кэш-память (L1, L2, иногда L3) на одном кристалле. RAM, диск и видеокарта — внешние компоненты."
  },
  {
    "text": "Что такое машинный цикл?",
    "type": "choice",
    "options": ["Время выполнения одной программы", "Последовательность выборки, декодирования и выполнения команды", "Тактовая частота процессора", "Время доступа к оперативной памяти"],
    "correct": "B",
    "comment": "Машинный цикл включает: выборку команды из памяти, декодирование (определение операции и операндов), выполнение (в ALU или другом блоке). Это основной цикл работы процессора."
  },
  {
    "text": "Как называется регистр, хранящий признаки результата операции (например, ноль, перенос)?",
    "type": "choice",
    "options": ["Аккумулятор", "Счётчик команд", "Регистр флагов", "Указатель стека"],
    "correct": "C",
    "comment": "Регистр флагов (Flags Register) содержит биты, отражающие состояние после операции: ZF (zero flag), CF (carry flag), SF (sign flag) и др. Используется для условных переходов."
  },
  {
    "text": "Какая память является энергозависимой?",
    "type": "choice",
    "options": ["ROM", "Flash", "RAM", "ПЗУ"],
    "correct": "C",
    "comment": "RAM (оперативная память) теряет данные при отключении питания. ROM, Flash, ПЗУ — энергонезависимы."
  },
  {
    "text": "Что такое шина данных?",
    "type": "choice",
    "options": ["Линия для передачи адреса ячейки памяти", "Линия для передачи управляющих сигналов", "Линия для передачи данных между ЦП и памятью", "Соединение между ядрами процессора"],
    "correct": "C",
    "comment": "Шина данных передаёт значения (операнды, результаты). Шина адреса — адреса, шина управления — сигналы типа «чтение/запись»."
  },
  {
    "text": "Какой принцип обеспечивает последовательное выполнение команд в архитектуре фон Неймана?",
    "type": "choice",
    "options": ["Принцип двоичного кодирования", "Принцип хранимой программы", "Принцип открытой архитектуры", "Принцип модульности"],
    "correct": "B",
    "comment": "Принцип хранимой программы гласит, что команды программы хранятся в памяти как данные и выбираются последовательно. Это ключевая идея фон Неймана."
  },
  {
    "text": "Какие утверждения верны для архитектуры фон Неймана?",
    "type": "choice",
    "options": ["Команды и данные имеют одинаковый формат", "Выборка команды и чтение данных происходят одновременно", "Используется одна шина для данных и команд", "C и A"],
    "correct": "D",
    "comment": "В архитектуре фон Неймана команды и данные хранятся в одной памяти и могут иметь одинаковый формат (битовая строка). Но из-за единой шины одновременная выборка невозможна — это ограничение. Поэтому верны A и C."
  },
  {
    "text": "Что такое аккумулятор в контексте процессора?",
    "type": "choice",
    "options": ["Регистр для хранения промежуточных результатов", "Источник питания процессора", "Элемент кэш-памяти", "Регистр флагов"],
    "correct": "A",
    "comment": "В ранних процессорах аккумулятор был основным регистром для арифметических операций. В современных CPU его функции распределены между общими регистрами, но термин иногда используется."
  },
  {
    "text": "Какой компонент определяет разрядность процессора?",
    "type": "choice",
    "options": ["Размер шины данных", "Размер регистра общего назначения", "Размер шины адреса", "Все вышеперечисленное"],
    "correct": "D",
    "comment": "Разрядность (32-битная, 64-битная) определяется шириной шины данных, адреса и регистров. Например, 64-битный процессор имеет 64-битные регистры, шину данных и может адресовать до 2⁶⁴ байт памяти."
  },
  {
    "text": "Что такое кэш-память?",
    "type": "choice",
    "options": ["Энергонезависимая память для хранения BIOS", "Быстрая память между ЦП и ОЗУ для ускорения доступа", "Виртуальная память на диске", "Регистры процессора"],
    "correct": "B",
    "comment": "Кэш — это маленькая, но очень быстрая память, хранящая копии часто используемых данных из ОЗУ. Уменьшает простои ЦП при ожидании данных."
  },
  {
    "text": "Какой регистр указывает на вершину стека?",
    "type": "choice",
    "options": ["PC", "SP", "IR", "AX"],
    "correct": "B",
    "comment": "SP (Stack Pointer) — указатель стека, хранит адрес последнего элемента в стеке. При push/pop он автоматически изменяется."
  },
  {
    "text": "Что происходит на этапе «декодирование» в машинном цикле?",
    "type": "choice",
    "options": ["Команда считывается из памяти", "Определяется тип операции и операнды", "Выполняется арифметическая операция", "Результат записывается в память"],
    "correct": "B",
    "comment": "На этапе декодирования блок управления интерпретирует битовое представление команды и формирует управляющие сигналы для ALU, регистров и шин."
  },
  {
    "text": "Какая память используется для хранения программы начальной загрузки (BIOS/UEFI)?",
    "type": "choice",
    "options": ["RAM", "ROM", "Кэш", "Регистры"],
    "correct": "B",
    "comment": "ROM (Read-Only Memory) — энергонезависимая память, в которой хранится firmware (BIOS/UEFI). Современные системы используют Flash-ROM, которую можно перезаписывать."
  },
  {
    "text": "Что такое тактовая частота процессора?",
    "type": "choice",
    "options": ["Количество команд, выполняемых за секунду", "Число импульсов генератора в секунду, синхронизирующих работу ЦП", "Скорость передачи данных по шине", "Объём кэш-памяти"],
    "correct": "B",
    "comment": "Тактовая частота (например, 3.5 ГГц) — это количество тактов (циклов) в секунду. Каждая операция занимает определённое число тактов. Не путать с производительностью (MIPS), которая зависит и от архитектуры."
  },
  {
    "text": "Какой блок управляет работой всех компонентов процессора?",
    "type": "choice",
    "options": ["ALU", "CU", "SP", "PC"],
    "correct": "B",
    "comment": "CU (Control Unit) — блок управления, который координирует работу ALU, регистров, шин, генерируя управляющие сигналы в нужные моменты времени."
  },
  {
    "text": "Что такое регистр IR (Instruction Register)?",
    "type": "choice",
    "options": ["Регистр, хранящий текущую выполняемую команду", "Регистр для хранения промежуточных данных", "Счётчик команд", "Указатель стека"],
    "correct": "A",
    "comment": "IR (Instruction Register) временно хранит команду, выбранную из памяти, пока она декодируется и выполняется."
  },
  {
    "text": "Какие характеристики относятся к оперативной памяти (RAM)?",
    "type": "choice",
    "options": ["Энергозависимость, высокая скорость, произвольный доступ", "Энергонезависимость, низкая скорость", "Последовательный доступ, большая ёмкость", "Используется только для кэширования"],
    "correct": "A",
    "comment": "RAM — энергозависимая, но быстрая память с произвольным доступом (любая ячейка за одно обращение). Используется для хранения данных и команд во время выполнения программы."
  },
  {
    "text": "Что такое «модель вычислений фон Неймана»?",
    "type": "choice",
    "options": ["Теоретическая модель, включающая процессор, память и устройства ввода/вывода", "Конкретная реализация процессора Intel", "Модель параллельных вычислений", "Алгоритм сортировки"],
    "correct": "A",
    "comment": "Это абстрактная модель компьютера, предложенная Джоном фон Нейманом в 1945 году. Она легла в основу почти всех современных компьютеров."
  },
  {
    "text": "Какой компонент позволяет процессору взаимодействовать с периферийными устройствами?",
    "type": "choice",
    "options": ["Шина ввода/вывода", "ALU", "Регистр флагов", "Кэш-память"],
    "correct": "A",
    "comment": "Шина ввода/вывода (или контроллеры ввода/вывода) обеспечивают обмен данными между ЦП и периферией (клавиатура, диск, сеть)."
  },
  {
    "text": "Укажите три основных блока архитектуры фон Неймана.",
    "type": "choice",
    "options": ["Центральный процессор (ЦП), оперативная память, устройства ввода/вывода", "Процессор, кэш, шина", "Ядро, ОЗУ, диск", "ALU, CU, регистры"],
    "correct": "A",
    "comment": "Эти три компонента соединены общей шиной и образуют классическую модель компьютера. Иногда шину выделяют как четвёртый блок."
  },
  {
    "text": "Напишите название регистра, который хранит адрес следующей команды.",
    "type": "choice",
    "options": ["Program Counter (PC) или счётчик команд", "Указатель стека (SP)", "Регистр флагов", "Аккумулятор"],
    "correct": "A",
    "comment": "Этот регистр автоматически увеличивается после выборки каждой команды, обеспечивая последовательное выполнение программы."
  },
  {
    "text": "Укажите два компонента, входящих в состав центрального процессора (CPU).",
    "type": "choice",
    "options": ["Арифметико-логическое устройство (ALU) и блок управления (CU)", "Оперативная память и жёсткий диск", "Шина данных и шина адреса", "Кэш L3 и регистр флагов"],
    "correct": "A",
    "comment": "Также правильны: регистры, кэш-память, шина внутри CPU. Главное — указать внутренние части ЦП, а не внешние устройства."
  },
  {
    "text": "Напишите, что означает аббревиатура ALU.",
    "type": "choice",
    "options": ["Арифметико-логическое устройство", "Адресное логическое устройство", "Автоматический логический узел", "Аналитический логический усилитель"],
    "correct": "A",
    "comment": "ALU отвечает за выполнение базовых операций: сложение, вычитание, логические И/ИЛИ/НЕ, сдвиги."
  },
  {
    "text": "Укажите, почему архитектура фон Неймана называется «архитектурой с хранимой программой».",
    "type": "choice",
    "options": ["Потому что команды программы хранятся в той же памяти, что и данные, и могут быть изменены как обычные данные", "Потому что программа хранится на жёстком диске", "Потому что используется только один процессор", "Потому что программа не может быть изменена во время выполнения"],
    "correct": "A",
    "comment": "Это позволяет создавать самомодифицирующиеся программы и интерпретаторы, но также делает систему уязвимой к атакам (например, переполнение буфера)."
  },
  {
    "text": "Напишите название регистра, который хранит признаки результата операции (например, «результат равен нулю»).",
    "type": "choice",
    "options": ["Регистр флагов", "Счётчик команд", "Аккумулятор", "Указатель стека"],
    "correct": "A",
    "comment": "Также допустимо: FLAGS register, status register. Он используется командами условного перехода."
  },
  {
    "text": "Укажите разницу между архитектурой фон Неймана и гарвардской архитектурой.",
    "type": "choice",
    "options": ["В архитектуре фон Неймана команды и данные хранятся в одной памяти и передаются по одной шине, а в гарвардской — в раздельных памятях и по раздельным шинам", "Гарвардская архитектура использует только один регистр", "Архитектура фон Неймана не поддерживает многопоточность", "Гарвардская архитектура медленнее"],
    "correct": "A",
    "comment": "Гарвардская архитектура позволяет одновременно выбирать команду и читать данные, что повышает производительность, но усложняет программирование."
  },
  {
    "text": "Напишите, что такое «фон-неймановское узкое место».",
    "type": "choice",
    "options": ["Ограничение производительности, вызванное тем, что команды и данные передаются по одной шине, что не позволяет выполнять выборку команды и чтение данных одновременно", "Ограничение на количество регистров", "Медленная работа кэш-памяти", "Ошибки в микрокоде процессора"],
    "correct": "A",
    "comment": "Это фундаментальное ограничение, которое пытаются обойти с помощью кэшей, конвейеризации и других методов."
  },
  {
    "text": "Укажите, какие виды памяти являются энергозависимыми.",
    "type": "choice",
    "options": ["Оперативная память (RAM), кэш-память, регистры", "ROM, Flash, HDD", "Только RAM", "Все виды памяти"],
    "correct": "A",
    "comment": "Все они теряют данные при отключении питания. Энергонезависимые: ROM, Flash, HDD, SSD."
  },
  {
    "text": "Напишите название блока процессора, который декодирует команды и управляет потоком данных.",
    "type": "choice",
    "options": ["Блок управления (Control Unit, CU)", "ALU", "Кэш-память", "Шина данных"],
    "correct": "A",
    "comment": "CU интерпретирует машинный код и генерирует управляющие сигналы для других частей процессора."
  },
  {
    "text": "Укажите, что хранится в регистре IR.",
    "type": "choice",
    "options": ["Текущая выполняемая команда", "Адрес следующей команды", "Результат последней операции", "Флаги состояния"],
    "correct": "A",
    "comment": "IR (Instruction Register) временно сохраняет команду после её выборки из памяти и до завершения выполнения."
  },
  {
    "text": "Напишите, как называется регистр, указывающий на вершину стека.",
    "type": "choice",
    "options": ["Указатель стека (Stack Pointer, SP)", "Счётчик команд (PC)", "Регистр флагов", "Аккумулятор"],
    "correct": "A",
    "comment": "При операциях push и pop значение SP автоматически изменяется."
  },
  {
    "text": "Укажите три типа шин в компьютере.",
    "type": "choice",
    "options": ["Шина данных, шина адреса, шина управления", "Шина PCI, шина USB, шина SATA", "Внутренняя шина, внешняя шина, системная шина", "Шина CPU, шина RAM, шина GPU"],
    "correct": "A",
    "comment": "Шина данных — для передачи значений, шина адреса — для указания ячейки памяти, шина управления — для сигналов типа «чтение», «запись», «прерывание»."
  },
  {
    "text": "Напишите, что означает термин «машинный цикл».",
    "type": "choice",
    "options": ["Последовательность операций: выборка команды из памяти, декодирование, выполнение, запись результата", "Время выполнения одной инструкции", "Тактовая частота процессора", "Цикл обновления кэш-памяти"],
    "correct": "A",
    "comment": "Это базовый цикл работы процессора. В простых архитектурах одна команда = один цикл, в конвейерных — несколько команд на разных стадиях."
  },
  {
    "text": "Укажите, где хранится программа BIOS/UEFI.",
    "type": "choice",
    "options": ["В энергонезависимой памяти (ROM или Flash) на материнской плате", "В оперативной памяти", "На жёстком диске", "В регистрах процессора"],
    "correct": "A",
    "comment": "Эта память сохраняет содержимое при выключении питания и содержит код начальной загрузки."
  },
  {
    "text": "Напишите, что такое кэш-память и зачем она нужна.",
    "type": "choice",
    "options": ["Кэш-память — это быстрая память небольшого объёма, расположенная близко к процессору, предназначенная для хранения копий часто используемых данных из оперативной памяти, чтобы уменьшить время ожидания данных", "Это резервная копия BIOS", "Это виртуальная память на диске", "Это память для хранения временных файлов"],
    "correct": "A",
    "comment": "Без кэша процессор простаивал бы миллионы тактов, ожидая данные из медленной RAM."
  },
  {
    "text": "Укажите, какой регистр используется для хранения промежуточных результатов вычислений в классических процессорах.",
    "type": "choice",
    "options": ["Аккумулятор", "Счётчик команд", "Указатель стека", "Регистр флагов"],
    "correct": "A",
    "comment": "В современных процессорах функции аккумулятора распределены между регистрами общего назначения, но термин всё ещё используется."
  },
  {
    "text": "Напишите, что определяет разрядность процессора.",
    "type": "choice",
    "options": ["Ширина регистров, шины данных и шины адреса (например, 32 или 64 бита)", "Количество ядер", "Тактовая частота", "Объём кэш-памяти"],
    "correct": "A",
    "comment": "Разрядность влияет на максимальный объём адресуемой памяти и производительность при работе с большими числами."
  },
  {
    "text": "Укажите, какая память используется для временного хранения данных и команд во время выполнения программы.",
    "type": "choice",
    "options": ["Оперативная память (RAM)", "Кэш-память", "Регистры", "Жёсткий диск"],
    "correct": "A",
    "comment": "RAM — основная рабочая память компьютера. Она энергозависима, но быстра по сравнению с диском."
  },
  {
    "text": "Напишите, что такое тактовая частота и в каких единицах она измеряется.",
    "type": "choice",
    "options": ["Тактовая частота — это количество тактов (циклов) процессора в секунду; измеряется в герцах (Гц, МГц, ГГц)", "Это скорость передачи данных по шине", "Это количество команд в секунду", "Это объём кэш-памяти"],
    "correct": "A",
    "comment": "Такт — это минимальная временная единица, за которую процессор может выполнить часть операции."
  },
  {
    "text": "Укажите, какие компоненты входят в состав процессора (CPU).",
    "type": "choice",
    "options": ["ALU, блок управления, регистры, кэш-память", "Оперативная память, жёсткий диск, видеокарта", "Шина данных, шина адреса, шина управления", "BIOS, UEFI, драйверы"],
    "correct": "A",
    "comment": "Все эти компоненты интегрированы на одном кристалле в современных процессорах."
  },
  {
    "text": "Напишите, что происходит на этапе «выборка» в машинном цикле.",
    "type": "choice",
    "options": ["Процессор считывает команду из памяти по адресу, указанному в счётчике команд (PC)", "Декодирует команду", "Выполняет арифметическую операцию", "Записывает результат в регистр"],
    "correct": "A",
    "comment": "После выборки PC увеличивается на длину команды, готовясь к следующему циклу."
  },
  {
    "text": "Укажите, почему гарвардская архитектура используется в микроконтроллерах.",
    "type": "choice",
    "options": ["Потому что она позволяет одновременно выбирать команду и читать данные, что повышает скорость выполнения программ, особенно в реальном времени", "Потому что она проще в реализации", "Потому что она дешевле", "Потому что она совместима с Windows"],
    "correct": "A",
    "comment": "В микроконтроллерах программа обычно не меняется во время выполнения, поэтому раздельная память безопасна и эффективна."
  },
  {
    "text": "Напишите, что такое регистр общего назначения.",
    "type": "choice",
    "options": ["Регистр процессора, который может использоваться программистом для хранения любых данных (адресов, значений, промежуточных результатов)", "Регистр, содержащий адрес следующей команды", "Регистр флагов", "Специальный регистр для работы с памятью"],
    "correct": "A",
    "comment": "В отличие от специальных регистров (PC, SP, FLAGS), регистры общего назначения (например, EAX, EBX в x86) гибко используются в программах."
  },
  {
    "text": "Укажите, как взаимодействуют процессор и оперативная память в архитектуре фон Неймана.",
    "type": "choice",
    "options": ["Процессор и память соединены общей шиной; процессор отправляет адрес по шине адреса, а данные передаются по шине данных в обоих направлениях", "Процессор напрямую подключён к каждому байту памяти", "Память встроена в процессор", "Процессор использует только кэш-память"],
    "correct": "A",
    "comment": "Это взаимодействие лежит в основе фон-неймановского узкого места, так как шина используется и для команд, и для данных."
  }
],

  "type_09": [
  {
    "text": "Какая сетевая топология требует терминаторов на концах кабеля?",
    "type": "choice",
    "options": ["Звезда", "Кольцо", "Шина", "Полносвязная"],
    "correct": "C",
    "comment": "В топологии «шина» все узлы подключены к одному общему кабелю. Чтобы предотвратить отражение сигнала, на обоих концах устанавливаются терминаторы (согласующие резисторы). В звезде (A) используется коммутатор, в кольце (B) — сигнал циркулирует, терминаторы не нужны."
  },
  {
    "text": "Какое устройство работает на канальном уровне модели OSI?",
    "type": "choice",
    "options": ["Маршрутизатор", "Коммутатор", "Концентратор", "Повторитель"],
    "correct": "B",
    "comment": "Коммутатор (switch) использует MAC-адреса для пересылки кадров — это признак канального уровня (уровень 2). Маршрутизатор (A) работает на сетевом уровне (IP-адреса), концентратор (C) и повторитель (D) — на физическом уровне (просто усиливают сигнал)."
  },
  {
    "text": "Какие характеристики верны для топологии «звезда»?",
    "type": "choice",
    "options": ["Отказ центрального коммутатора выводит всю сеть из строя", "Требует меньше кабеля, чем топология «шина»", "Легко диагностировать неисправный узел", "Не требует активного сетевого оборудования"],
    "correct": "A, C",
    "comment": "В звезде все узлы подключены к центральному устройству (коммутатору или хабу). Если оно выходит из строя — сеть падает (A). Диагностика проста: каждый узел изолирован (C). Однако звезда требует больше кабеля, чем шина (B — неверно), и обязательно требует активного оборудования (D — неверно)."
  },
  {
    "text": "Какой уровень модели OSI отвечает за маршрутизацию пакетов между сетями?",
    "type": "choice",
    "options": ["Физический", "Канальный", "Сетевой", "Транспортный"],
    "correct": "C",
    "comment": "Сетевой уровень (уровень 3) использует логические адреса (например, IP) и обеспечивает доставку пакетов между разными сетями. Маршрутизаторы работают именно на этом уровне."
  },
  {
    "text": "Что такое MAC-адрес?",
    "type": "choice",
    "options": ["Уникальный аппаратный адрес сетевого интерфейса", "IP-адрес, назначенный DHCP-сервером", "Имя компьютера в локальной сети", "Порт, используемый приложением"],
    "correct": "A",
    "comment": "MAC-адрес (Media Access Control) — это жёстко запрограммированный 48-битный адрес сетевой карты, уникальный в пределах производителя. Он используется на канальном уровне для доставки кадров внутри одной сети."
  },
  {
    "text": "Какое устройство работает на физическом уровне модели OSI?",
    "type": "choice",
    "options": ["Коммутатор", "Маршрутизатор", "Концентратор", "Точка доступа Wi-Fi"],
    "correct": "C",
    "comment": "Концентратор (хаб) просто ретранслирует входящий сигнал на все порты без анализа адресов. Это делает его устройством физического уровня (уровень 1). Коммутатор (A) — уровень 2, маршрутизатор (B) — уровень 3, точка доступа (D) — обычно уровень 2."
  },
  {
    "text": "Какие утверждения верны для топологии «кольцо»?",
    "type": "choice",
    "options": ["Данные передаются в одном направлении", "Отказ одного узла может нарушить работу всей сети", "Не требует центрального устройства", "Легко масштабируется добавлением новых узлов"],
    "correct": "A, B, C",
    "comment": "В классическом кольце данные циркулируют в одном направлении (A). Если один узел выходит из строя, кольцо разрывается — сеть перестаёт работать (B). Центрального устройства нет (C). Однако масштабирование затруднено: добавление узла требует временного отключения сети, и увеличивается задержка (D — неверно)."
  },
  {
    "text": "На каком уровне модели OSI работают протоколы TCP и UDP?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Сеансовый", "Прикладной"],
    "correct": "B",
    "comment": "Транспортный уровень (уровень 4) обеспечивает надёжную (TCP) или ненадёжную (UDP) доставку данных между процессами на разных хостах. Он использует порты для мультиплексирования приложений."
  },
  {
    "text": "Какая топология наиболее устойчива к отказу отдельных узлов?",
    "type": "choice",
    "options": ["Шина", "Звезда", "Кольцо", "Полносвязная"],
    "correct": "D",
    "comment": "В полносвязной топологии каждый узел соединён напрямую со всеми остальными. Отказ одного узла не влияет на связь между другими. В шине (A) обрыв кабеля убивает сеть, в кольце (C) — отказ узла, в звезде (B) — отказ центрального устройства."
  },
  {
    "text": "Что такое IP-адрес?",
    "type": "choice",
    "options": ["Аппаратный адрес сетевой карты", "Логический адрес, используемый для маршрутизации в сетях", "Имя домена", "Номер порта"],
    "correct": "B",
    "comment": "IP-адрес — это логический адрес сетевого уровня, назначаемый ОС или DHCP-сервером. Он используется для маршрутизации пакетов между сетями. MAC-адрес (A) — аппаратный, доменное имя (C) преобразуется в IP через DNS."
  },
  {
    "text": "Какое устройство соединяет разные сети и выбирает оптимальный путь для пакетов?",
    "type": "choice",
    "options": ["Коммутатор", "Концентратор", "Маршрутизатор", "Модем"],
    "correct": "C",
    "comment": "Маршрутизатор (router) работает на сетевом уровне и принимает решения о пересылке пакетов на основе таблицы маршрутизации. Коммутатор (A) работает внутри одной сети, концентратор (B) — просто ретранслирует, модем (D) преобразует цифровой сигнал в аналоговый."
  },
  {
    "text": "Какие характеристики верны для топологии «шина»?",
    "type": "choice",
    "options": ["Все узлы получают все передаваемые данные", "Отказ одного узла не нарушает работу остальных", "Требуются терминаторы на концах кабеля", "Легко масштабируется добавлением новых узлов"],
    "correct": "A, B, C",
    "comment": "В шине все узлы подключены к общему кабелю, поэтому все получают все кадры (A). Отказ одного компьютера не влияет на других (B). Терминаторы обязательны (C). Однако масштабирование ограничено: при большом числе узлов растут коллизии и отражения сигнала (D — неверно)."
  },
  {
    "text": "На каком уровне модели OSI работают протоколы HTTP, FTP, SMTP?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Сеансовый", "Прикладной"],
    "correct": "D",
    "comment": "Прикладной уровень (уровень 7) предоставляет сервисы напрямую пользовательским приложениям. HTTP (веб), FTP (передача файлов), SMTP (почта) — все работают на этом уровне."
  },
  {
    "text": "Что такое DHCP?",
    "type": "choice",
    "options": ["Протокол для разрешения имён в IP-адреса", "Протокол для автоматического назначения IP-адресов", "Протокол для безопасной передачи данных", "Протокол для синхронизации времени"],
    "correct": "B",
    "comment": "DHCP (Dynamic Host Configuration Protocol) автоматически выдаёт клиентам IP-адрес, маску подсети, шлюз и DNS-серверы. DNS (A) отвечает за разрешение имён, TLS/SSL (C) — за шифрование, NTP (D) — за время."
  },
  {
    "text": "Какой протокол используется для разрешения IP-адреса в MAC-адрес в локальной сети?",
    "type": "choice",
    "options": ["DNS", "DHCP", "ARP", "ICMP"],
    "correct": "C",
    "comment": "ARP (Address Resolution Protocol) отправляет широковещательный запрос: «Кто имеет IP X.X.X.X?». Владелец отвечает своим MAC-адресом. DNS (A) работает с доменными именами, DHCP (B) — с выдачей IP, ICMP (D) — с диагностикой (ping, traceroute)."
  },
  {
    "text": "Какая топология требует наибольшего количества кабеля?",
    "type": "choice",
    "options": ["Шина", "Звезда", "Кольцо", "Полносвязная"],
    "correct": "D",
    "comment": "В полносвязной топологии с N узлами требуется N(N–1)/2 соединений. Для 5 узлов — 10 кабелей. В звезде — N кабелей, в шине и кольце — N (или N+1)."
  },
  {
    "text": "Какое устройство может фильтровать трафик на основе IP-адресов и портов?",
    "type": "choice",
    "options": ["Концентратор", "Коммутатор", "Маршрутизатор", "Брандмауэр"],
    "correct": "D",
    "comment": "Брандмауэр (firewall) анализирует пакеты на сетевом и транспортном уровнях и принимает решение о пропуске/блокировке по правилам (IP, порт, протокол). Маршрутизатор (C) может иметь функции брандмауэра, но сам по себе — нет."
  },
  {
    "text": "Что такое DNS?",
    "type": "choice",
    "options": ["Протокол для автоматической настройки сети", "Система, преобразующая доменные имена в IP-адреса", "Протокол для проверки связи", "Устройство для усиления сигнала"],
    "correct": "B",
    "comment": "DNS (Domain Name System) позволяет использовать понятные имена (google.com) вместо числовых IP-адресов (142.250.180.46). Запросы обрабатываются DNS-серверами."
  },
  {
    "text": "Какой уровень модели OSI обеспечивает надёжную доставку данных с подтверждением?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Канальный", "Физический"],
    "correct": "B",
    "comment": "Транспортный уровень (TCP) обеспечивает надёжность через нумерацию, подтверждение и повторную передачу потерянных сегментов. UDP на том же уровне — без подтверждения."
  },
  {
    "text": "Какие устройства работают на канальном уровне?",
    "type": "choice",
    "options": ["Коммутатор", "Точка доступа Wi-Fi", "Мост", "Концентратор"],
    "correct": "A, B, C",
    "comment": "Коммутатор, точка доступа и мост используют MAC-адреса для фильтрации и пересылки кадров — это уровень 2. Концентратор (D) работает на физическом уровне."
  },
  {
    "text": "Что такое широковещательный (broadcast) домен?",
    "type": "choice",
    "options": ["Группа устройств, получающих широковещательные пакеты", "Группа устройств с одинаковым IP-адресом", "Сеть, защищённая брандмауэром", "Группа устройств в одном VLAN"],
    "correct": "A",
    "comment": "Широковещательный домен — это сегмент сети, где все устройства получают broadcast-пакеты (например, ARP-запросы). Маршрутизаторы разделяют broadcast-домены, коммутаторы — нет."
  },
  {
    "text": "Какой протокол используется для проверки связи с удалённым хостом?",
    "type": "choice",
    "options": ["HTTP", "FTP", "ICMP", "ARP"],
    "correct": "C",
    "comment": "Команда `ping` использует протокол ICMP (Internet Control Message Protocol) для отправки эхо-запросов и получения эхо-ответов. ARP (D) работает только в локальной сети."
  },
  {
    "text": "Что такое VLAN?",
    "type": "choice",
    "options": ["Виртуальная локальная сеть, логически выделенная на коммутаторе", "Тип кабеля для высокоскоростных сетей", "Протокол шифрования трафика", "Устройство для подключения к интернету"],
    "correct": "A",
    "comment": "VLAN (Virtual Local Area Network) позволяет создать несколько изолированных сетей на одном физическом коммутаторе. Устройства в разных VLAN не могут напрямую обмениваться трафиком без маршрутизатора."
  },
  {
    "text": "Какой уровень модели OSI отвечает за физическую передачу битов по среде?",
    "type": "choice",
    "options": ["Физический", "Канальный", "Сетевой", "Транспортный"],
    "correct": "A",
    "comment": "Физический уровень (уровень 1) определяет электрические, механические и временные характеристики передачи: тип кабеля, разъёмы, уровни напряжения, скорость передачи."
  },
  {
    " text": "Какое устройство объединяет сегменты сети на канальном уровне?",
    "type": "choice",
    "options": ["Повторитель", "Мост", "Маршрутизатор", "Шлюз"],
    "correct": "B",
    "comment": "Мост (bridge) фильтрует трафик между сегментами на основе MAC-адресов — это уровень 2. Повторитель (A) — уровень 1, маршрутизатор (C) — уровень 3."
  },
  {
    "text": "Что такое коллизия в сети?",
    "type": "choice",
    "options": ["Одновременная передача данных двумя узлами в сети с общей средой", "Ошибка в IP-адресе", "Потеря пакета из-за перегрузки", "Атака типа «отказ в обслуживании»"],
    "correct": "A",
    "comment": "В сетях с общей средой (шина, старые хабы) два узла могут начать передачу одновременно — сигналы накладываются, возникает коллизия. Протокол CSMA/CD (в Ethernet) обнаруживает и разрешает коллизии."
  },
  {
    "text": "Какие утверждения верны для коммутатора?",
    "type": "choice",
    "options": ["Создаёт отдельный коллизионный домен для каждого порта", "Передаёт кадры только целевому узлу", "Работает на сетевом уровне", "Использует MAC-адреса для принятия решений"],
    "correct": "A, B, D",
    "comment": "Коммутатор изучает MAC-адреса и строит таблицу, чтобы пересылать кадры только нужному порту (B, D). Это устраняет коллизии между портами (A). Он работает на канальном уровне, а не сетевом (C — неверно)."
  },
  {
    "text": "Что такое шлюз по умолчанию?",
    "type": "choice",
    "options": ["Устройство, предоставляющее IP-адреса", "Маршрутизатор, через который трафик покидает локальную сеть", "Сервер имён DNS", "Устройство для усиления сигнала"],
    "correct": "B",
    "comment": "Шлюз по умолчанию — это IP-адрес маршрутизатора в локальной сети. Когда компьютер хочет отправить пакет во внешнюю сеть, он направляет его этому маршрутизатору."
  },
  {
    "text": "Какой протокол используется для динамического назначения IP-адресов?",
    "type": "choice",
    "options": ["ARP", "DNS", "DHCP", "ICMP"],
    "correct": "C",
    "comment": "DHCP (Dynamic Host Configuration Protocol) автоматически выдаёт клиентам IP-адрес, маску, шлюз, DNS-серверы. ARP (A) — для MAC-адресов, DNS (B) — для имён, ICMP (D) — для диагностики."
  },
  {
    "text": "Какая топология наиболее проста в установке для небольшой сети?",
    "type": "choice",
    "options": ["Шина", "Звезда", "Кольцо", "Ячеистая"],
    "correct": "B",
    "comment": "Звезда легко монтируется: каждый компьютер подключается кабелем к центральному коммутатору. Шина (A) требует аккуратной прокладки общего кабеля и терминаторов, кольцо (C) — сложнее в настройке."
  },
  {
    "text": "Что такое MAC-фильтрация?",
    "type": "choice",
    "options": ["Блокировка трафика по IP-адресу", "Разрешение доступа к сети только устройствам с определёнными MAC-адресами", "Шифрование трафика по MAC-адресу", "Автоматическое назначение MAC-адресов"],
    "correct": "B",
    "comment": "MAC-фильтрация — метод безопасности, при котором точка доступа или маршрутизатор разрешает подключение только известным MAC-адресам. Однако её легко обойти подменой MAC-адреса (spoofing)."
  },
  {
    "text": "Какой уровень модели OSI обеспечивает управление сеансом связи между приложениями?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Сеансовый", "Представительский"],
    "correct": "C",
    "comment": "Сеансовый уровень (уровень 5) управляет установлением, поддержанием и завершением сеансов связи (например, синхронизация, восстановление после сбоя). В TCP/IP эта функция часто реализуется на прикладном уровне."
  },
  {
    "text": "Что такое NAT?",
    "type": "choice",
    "options": ["Протокол для разрешения имён", "Механизм преобразования частных IP-адресов в публичный", "Протокол шифрования", "Устройство для подключения к интернету"],
    "correct": "B",
    "comment": "NAT (Network Address Translation) позволяет нескольким устройствам в локальной сети использовать один публичный IP-адрес для выхода в интернет. Маршрутизатор заменяет внутренний IP на свой внешний при отправке пакета."
  },
  {
    "text": "Какое устройство работает на всех уровнях модели OSI?",
    "type": "choice",
    "options": ["Коммутатор", "Маршрутизатор", "Шлюз", "Концентратор"],
    "correct": "C",
    "comment": "Шлюз (gateway) преобразует данные между разными сетевыми архитектурами (например, Ethernet и Wi-Fi, или TCP/IP и IPX/SPX), что требует работы на всех уровнях. Остальные устройства работают на 1–3 уровнях."
  },
  {
    "text": "Что такое коллизионный домен?",
    "type": "choice",
    "options": ["Группа устройств, где возможны коллизии при передаче", "Группа устройств с одинаковым IP-адресом", "Сеть, защищённая паролем", "Группа устройств в одном broadcast-домене"],
    "correct": "A",
    "comment": "Коллизионный домен — сегмент сети, где одновременная передача вызывает коллизию. Хабы и шины создают один большой коллизионный домен, коммутаторы — отдельный для каждого порта."
  },
  {
    "text": "Какой протокол используется для синхронизации времени в сети?",
    "type": "choice",
    "options": ["HTTP", "FTP", "NTP", "SNMP"],
    "correct": "C",
    "comment": "NTP (Network Time Protocol) синхронизирует часы устройств в сети с высокой точностью. HTTP (A) — веб, FTP (B) — файлы, SNMP (D) — управление сетью."
  },
  {
    "text": "Какие утверждения верны для концентратора (хаба)?",
    "type": "choice",
    "options": ["Работает на физическом уровне", "Передаёт входящий сигнал на все порты", "Создаёт один коллизионный домен", "Использует MAC-адреса для фильтрации"],
    "correct": "A, B, C",
    "comment": "Хаб — «глупое» устройство: усиливает и ретранслирует сигнал на все порты (B), работает на уровне 1 (A), и все порты находятся в одном коллизионном домене (C). Он не анализирует MAC-адреса (D — неверно)."
  },
  {
    "text": "Что такое подсеть (subnet)?",
    "type": "choice",
    "options": ["Часть IP-сети, выделенная с помощью маски подсети", "Группа устройств с одинаковым MAC-адресом", "Тип сетевого кабеля", "Устройство для разделения сети"],
    "correct": "A",
    "comment": "Подсеть — логическое выделение части IP-адресного пространства с помощью маски подсети (например, 255.255.255.0). Позволяет эффективно использовать адреса и управлять маршрутизацией."
  },
  {
    "text": "Какой протокол используется для управления сетевыми устройствами?",
    "type": "choice",
    "options": ["HTTP", "FTP", "SNMP", "SMTP"],
    "correct": "C",
    "comment": "SNMP (Simple Network Management Protocol) позволяет собирать информацию (статистику, ошибки) и управлять устройствами (маршрутизаторами, коммутаторами) удалённо."
  },
  {
    "text": "Что такое Wi-Fi?",
    "type": "choice",
    "options": ["Стандарт проводных сетей", "Стандарт беспроводных локальных сетей (IEEE 802.11)", "Протокол маршрутизации", "Устройство для подключения к интернету"],
    "correct": "B",
    "comment": "Wi-Fi — торговая марка для технологий беспроводной связи, основанных на стандартах IEEE 802.11. Обеспечивает подключение устройств к локальной сети без кабелей."
  },
  {
    "text": "Какой уровень модели OSI отвечает за представление данных (кодировка, шифрование)?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Сеансовый", "Представительский"],
    "correct": "D",
    "comment": "Представительский уровень (уровень 6) преобразует данные в формат, понятный приложению: сжатие, шифрование, кодировка (ASCII, UTF-8). В TCP/IP эти функции часто выполняются на прикладном уровне."
  },
  {
    "text": "Что такое публичный IP-адрес?",
    "type": "choice",
    "options": ["Адрес, используемый только в локальной сети", "Адрес, маршрутизируемый в интернете", "Адрес, назначенный DHCP-сервером", "MAC-адрес сетевого интерфейса"],
    "correct": "B",
    "comment": "Публичный IP-адрес уникален в интернете и может быть достигнут из любой точки глобальной сети. Частные адреса (192.168.x.x, 10.x.x.x) используются только внутри локальных сетей."
  },
  {
    "text": "Какое устройство преобразует цифровой сигнал в аналоговый для передачи по телефонной линии?",
    "type": "choice",
    "options": ["Коммутатор", "Маршрутизатор", "Модем", "Концентратор"],
    "correct": "C",
    "comment": "Модем (модулятор-демодулятор) преобразует цифровые данные компьютера в аналоговые сигналы для передачи по телефонным линиям (и обратно). Современные DSL-модемы работают быстрее, но принцип тот же."
  },
  {
    "text": "Что такое MTU?",
    "type": "choice",
    "options": ["Максимальный размер единицы передачи (пакета)", "Минимальная скорость передачи данных", "Тип сетевого кабеля", "Протокол шифрования"],
    "correct": "A",
    "comment": "MTU (Maximum Transmission Unit) — максимальный размер кадра (в байтах), который может быть передан по каналу без фрагментации. Для Ethernet стандартный MTU = 1500 байт."
  },
  {
    "text": "Какой протокол обеспечивает надёжную передачу данных в интернете?",
    "type": "choice",
    "options": ["IP", "UDP", "TCP", "ICMP"],
    "correct": "C",
    "comment": "TCP (Transmission Control Protocol) обеспечивает надёжность через подтверждение, повторную передачу и управление потоком. IP (A) и UDP (B) — ненадёжные, ICMP (D) — для диагностики."
  },
  {
    "text": "Что такое маршрутизация?",
    "type": "choice",
    "options": ["Процесс передачи кадров внутри одной сети", "Процесс выбора пути для пакетов между сетями", "Процесс преобразования имён в IP-адреса", "Процесс шифрования трафика"],
    "correct": "B",
    "comment": "Маршрутизация — это определение оптимального пути для пакета от источника к получателю через промежуточные сети. Выполняется маршрутизаторами на основе таблиц маршрутизации."
  },
  {
    "text": "Какие утверждения верны для беспроводной сети (Wi-Fi)?",
    "type": "choice",
    "options": ["Использует радиоволны для передачи данных", "Может быть защищена паролем (WPA2, WPA3)", "Имеет меньшую пропускную способность, чем проводная сеть", "Не подвержена помехам"],
    "correct": "A, B, C",
    "comment": "Wi-Fi использует радиочастоты (A), поддерживает шифрование (B), но обычно уступает по скорости и стабильности проводным сетям (C). Однако он подвержен помехам от микроволновок, Bluetooth, стен (D — неверно)."
  },
  {
    "text": "Что такое прокси-сервер?",
    "type": "choice",
    "options": ["Устройство для усиления сигнала", "Сервер, выступающий посредником между клиентом и интернетом", "Протокол для передачи файлов", "Устройство для маршрутизации пакетов"],
    "correct": "B",
    "comment": "Прокси-сервер принимает запросы от клиентов, пересылает их в интернет и возвращает ответ. Используется для кэширования, фильтрации, анонимизации."
  },
  {
    "text": "Какой уровень модели OSI обеспечивает физическую адресацию (MAC)?",
    "type": "choice",
    "options": ["Физический", "Канальный", "Сетевой", "Транспортный"],
    "correct": "B",
    "comment": "Канальный уровень (уровень 2) отвечает за доставку кадров внутри одной сети с использованием MAC-адресов. Физический уровень (A) передаёт биты, но не знает о MAC."
  },
  {
    "text": "Что такое облачная сеть?",
    "type": "choice",
    "options": ["Сеть, построенная на виртуальных ресурсах, предоставляемых через интернет", "Сеть, использующая только беспроводные технологии", "Сеть с топологией «облако»", "Сеть, защищённая облачным брандмауэром"],
    "correct": "A",
    "comment": "Облачная сеть — это виртуальная инфраструктура (виртуальные машины, коммутаторы, маршрутизаторы), размещённая в дата-центрах провайдера (AWS, Azure, GCP) и доступная через интернет."
  }
],

  "type_10": [
  {
    "text": "На каком уровне модели OSI работают IP-адреса?",
    "type": "choice",
    "options": ["Физический", "Канальный", "Сетевой", "Транспортный"],
    "correct": "C",
    "comment": "IP-адреса используются для маршрутизации пакетов между сетями, что является функцией сетевого уровня (уровень 3). MAC-адреса (B) работают на канальном уровне — внутри одной сети."
  },
  {
    "text": "Какой протокол работает на транспортном уровне и обеспечивает надёжную доставку данных?",
    "type": "choice",
    "options": ["IP", "UDP", "TCP", "ARP"],
    "correct": "C",
    "comment": "TCP (Transmission Control Protocol) обеспечивает надёжность через подтверждение, повторную передачу и управление потоком. UDP (B) — ненадёжный, IP (A) — сетевой уровень, ARP (D) — канальный."
  },
  {
    "text": "Что такое маска подсети?",
    "type": "choice",
    "options": ["Устройство для фильтрации трафика", "Число, определяющее, какая часть IP-адреса относится к сети, а какая — к узлу", "Уникальный идентификатор сетевого интерфейса", "Протокол для назначения IP-адресов"],
    "correct": "B",
    "comment": "Маска подсети (например, 255.255.255.0) в двоичном виде состоит из единиц (сеть) и нулей (хост). Например, для 192.168.1.10/24 сеть = 192.168.1.0, хост = 10."
  },
  {
    "text": "Какие протоколы работают на прикладном уровне модели OSI?",
    "type": "choice",
    "options": ["HTTP", "FTP", "SMTP", "TCP"],
    "correct": "A, B, C",
    "comment": "HTTP (веб), FTP (файлы), SMTP (почта) — все предоставляют сервисы напрямую пользователю — это прикладной уровень (7). TCP (D) — транспортный уровень (4)."
  },
  {
    "text": "На каком уровне модели OSI работает протокол ARP?",
    "type": "choice",
    "options": ["Физический", "Канальный", "Сетевой", "Транспортный"],
    "correct": "B",
    "comment": "ARP (Address Resolution Protocol) преобразует IP-адрес в MAC-адрес в пределах одной локальной сети. Поскольку он использует MAC-адреса и широковещательные кадры, он относится к канальному уровню (2), хотя и обслуживает сетевой уровень."
  },
  {
    "text": "Какой диапазон IP-адресов зарезервирован для частных сетей?",
    "type": "choice",
    "options": ["10.0.0.0 – 10.255.255.255", "172.16.0.0 – 172.31.255.255", "192.168.0.0 – 192.168.255.255", "Все вышеперечисленные"],
    "correct": "D",
    "comment": "RFC 1918 определяет три диапазона для частного использования: — 10.0.0.0/8 (A), — 172.16.0.0/12 (B), — 192.168.0.0/16 (C). Эти адреса не маршрутизируются в интернете и используются в локальных сетях."
  },
  {
    "text": "Что такое шлюз по умолчанию?",
    "type": "choice",
    "options": ["Сервер DNS", "IP-адрес маршрутизатора, через который трафик покидает локальную сеть", "MAC-адрес коммутатора", "DHCP-сервер"],
    "correct": "B",
    "comment": "Шлюз по умолчанию — это маршрутизатор, подключённый к локальной сети. Когда компьютер отправляет пакет во внешнюю сеть, он направляет его этому маршрутизатору."
  },
  {
    "text": "На каком уровне модели OSI работают коммутаторы?",
    "type": "choice",
    "options": ["Физический", "Канальный", "Сетевой", "Транспортный"],
    "correct": "B",
    "comment": "Коммутаторы используют MAC-адреса для пересылки кадров — это признак канального уровня (2). Маршрутизаторы (C) работают с IP-адресами (уровень 3)."
  },
  {
    "text": "Какой протокол используется для диагностики связи (команда ping)?",
    "type": "choice",
    "options": ["TCP", "UDP", "ICMP", "ARP"],
    "correct": "C",
    "comment": "Команда `ping` использует ICMP (Internet Control Message Protocol) для отправки эхо-запросов и получения эхо-ответов. Это протокол сетевого уровня, но не для передачи данных, а для управления и диагностики."
  },
  {
    "text": "Что означает запись 192.168.1.0/24?",
    "type": "choice",
    "options": ["Сеть с 256 возможными хостами", "Сеть с 254 возможными хостами", "Отдельный IP-адрес", "Маска подсети 255.255.0.0"],
    "correct": "B",
    "comment": "/24 означает маску 255.255.255.0 → 8 бит для хостов → 2⁸ = 256 адресов, из них 254 доступны для хостов (первый — адрес сети, последний — широковещательный)."
  },
  {
    "text": "Какие функции выполняет сетевой уровень модели OSI?",
    "type": "choice",
    "options": ["Маршрутизация пакетов", "Логическая адресация (IP)", "Обнаружение ошибок в кадрах", "Управление потоком данных"],
    "correct": "A, B",
    "comment": "Сетевой уровень (3) отвечает за логическую адресацию (IP) и маршрутизацию между сетями. Обнаружение ошибок (C) — канальный уровень, управление потоком (D) — транспортный."
  },
  {
    "text": "Какой IP-адрес нельзя назначить хосту?",
    "type": "choice",
    "options": ["192.168.1.1", "10.0.0.1", "192.168.1.0", "172.16.0.10"],
    "correct": "C",
    "comment": "Адрес, где все биты хоста = 0 (например, 192.168.1.0 в сети /24), — это адрес сети и не может быть назначен хосту. Широковещательный адрес (все биты хоста = 1, например, 192.168.1.255) тоже не назначается."
  },
  {
    "text": "На каком уровне модели OSI работает протокол HTTP?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Сеансовый", "Прикладной"],
    "correct": "D",
    "comment": "HTTP — протокол передачи гипертекста, используемый веб-браузерами. Он предоставляет сервис напрямую пользователю — это прикладной уровень (7)."
  },
  {
    "text": "Что такое публичный IP-адрес?",
    "type": "choice",
    "options": ["Адрес из диапазона 192.168.0.0/16", "Адрес, маршрутизируемый в глобальном интернете", "Адрес, назначенный DHCP-сервером", "MAC-адрес сетевого интерфейса"],
    "correct": "B",
    "comment": "Публичный IP-адрес уникален в интернете и может быть достигнут из любой точки мира. Частные адреса (A) используются только внутри локальных сетей."
  },
  {
    "text": "Какой уровень модели OSI обеспечивает сквозную доставку данных между процессами?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Канальный", "Физический"],
    "correct": "B",
    "comment": "Транспортный уровень (4) использует порты для мультиплексирования приложений и обеспечивает доставку данных между конкретными процессами на разных хостах."
  },
  {
    "text": "Какие утверждения верны для протокола UDP?",
    "type": "choice",
    "options": ["Не гарантирует доставку", "Не использует подтверждения", "Имеет меньшие накладные расходы, чем TCP", "Обеспечивает упорядоченную доставку"],
    "correct": "A, B, C",
    "comment": "UDP — лёгкий, ненадёжный протокол: нет подтверждений, повторных передач, упорядочивания. Используется в VoIP, видео, DNS, где важна скорость, а не надёжность. Вариант D — свойство TCP."
  },
  {
    "text": "Что такое CIDR?",
    "type": "choice",
    "options": ["Протокол для разрешения имён", "Метод бесклассовой адресации (например, /24)", "Тип сетевого кабеля", "Устройство для маршрутизации"],
    "correct": "B",
    "comment": "CIDR (Classless Inter-Domain Routing) позволяет использовать маски переменной длины (например, 192.168.1.0/26), что повышает эффективность использования IP-адресов по сравнению со старой классовой адресацией (A, B, C классы)."
  },
  {
    "text": "На каком уровне модели OSI работает протокол DNS?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Сеансовый", "Прикладной"],
    "correct": "D",
    "comment": "DNS (Domain Name System) преобразует доменные имена в IP-адреса и предоставляет сервис приложениям — это прикладной уровень (7). Хотя DNS использует UDP/TCP (транспортный уровень), сам протокол — прикладной."
  },
  {
    "text": "Какой IP-адрес является широковещательным для сети 10.0.0.0/8?",
    "type": "choice",
    "options": ["10.0.0.0", "10.0.0.255", "10.255.255.255", "255.255.255.255"],
    "correct": "C",
    "comment": "В сети /8 (маска 255.0.0.0) все 24 бита хоста. Широковещательный адрес — все биты хоста = 1 → 10.255.255.255. Адрес D — ограниченное широковещание (внутри своей сети), но не для конкретной подсети."
  },
  {
    "text": "Что делает протокол DHCP?",
    "type": "choice",
    "options": ["Преобразует доменные имена в IP-адреса", "Назначает IP-адреса, маску, шлюз и DNS автоматически", "Проверяет связь с удалённым хостом", "Шифрует трафик"],
    "correct": "B",
    "comment": "DHCP (Dynamic Host Configuration Protocol) автоматизирует настройку сети: клиент получает IP, маску, шлюз, DNS-серверы без ручной конфигурации."
  },
  {
    "text": "Какой уровень модели OSI отвечает за физическую передачу битов?",
    "type": "choice",
    "options": ["Физический", "Канальный", "Сетевой", "Транспортный"],
    "correct": "A",
    "comment": "Физический уровень (1) определяет электрические, механические и временные характеристики передачи: тип кабеля, разъёмы, уровни напряжения, скорость передачи."
  },
  {
    "text": "Какие устройства работают на сетевом уровне модели OSI?",
    "type": "choice",
    "options": ["Маршрутизатор", "Многоуровневый коммутатор (L3 switch)", "Коммутатор", "Концентратор"],
    "correct": "A, B",
    "comment": "Маршрутизатор и L3-коммутатор принимают решения на основе IP-адресов — это сетевой уровень (3). Обычный коммутатор (C) — уровень 2, концентратор (D) — уровень 1."
  },
  {
    "text": "Что такое NAT?",
    "type": "choice",
    "options": ["Протокол для разрешения MAC-адресов", "Механизм преобразования частных IP-адресов в публичный", "Протокол для безопасной передачи файлов", "Устройство для усиления сигнала"],
    "correct": "B",
    "comment": "NAT (Network Address Translation) позволяет нескольким устройствам в локальной сети использовать один публичный IP-адрес для выхода в интернет. Выполняется на маршрутизаторе или файрволе."
  },
  {
    "text": "Какой протокол использует порт 53?",
    "type": "choice",
    "options": ["HTTP", "HTTPS", "DNS", "FTP"],
    "correct": "C",
    "comment": "DNS использует порт 53 по UDP (для запросов) и TCP (для зон transfer). HTTP — 80, HTTPS — 443, FTP — 21."
  },
  {
    "text": "Что такое localhost?",
    "type": "choice",
    "options": ["IP-адрес маршрутизатора", "Специальный IP-адрес 127.0.0.1 для обращения к самому себе", "Имя компьютера в локальной сети", "Сервер в интернете"],
    "correct": "B",
    "comment": "127.0.0.1 — это петлевой адрес (loopback), который всегда указывает на локальную машину. Используется для тестирования сетевых приложений без подключения к сети."
  },
  {
    "text": "На каком уровне модели OSI работает протокол SSL/TLS?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Сеансовый или представительский", "Физический"],
    "correct": "C",
    "comment": "SSL/TLS обеспечивает шифрование и аутентификацию. В модели OSI он обычно относится к сеансовому (5) или представительскому (6) уровню. В стеке TCP/IP он находится между прикладным и транспортным уровнями."
  },
  {
    "text": "Какой IP-адрес нельзя использовать в интернете?",
    "type": "choice",
    "options": ["8.8.8.8", "1.1.1.1", "192.168.1.1", "142.250.180.46"],
    "correct": "C",
    "comment": "192.168.1.1 — частный адрес, зарезервированный для локальных сетей (RFC 1918). Он не маршрутизируется в интернете. Остальные — публичные (Google DNS, Cloudflare, Google)."
  },
  {
    "text": "Что такое APIPA?",
    "type": "choice",
    "options": ["Автоматическое назначение IP-адреса из диапазона 169.254.0.0/16 при отсутствии DHCP", "Протокол для шифрования трафика", "Тип сетевого кабеля", "Устройство для подключения к интернету"],
    "correct": "A",
    "comment": "APIPA (Automatic Private IP Addressing) — функция Windows, которая присваивает адрес из 169.254.0.0/16, если DHCP-сервер недоступен. Такие адреса работают только в пределах одного сегмента."
  },
  {
    "text": "Какой уровень модели OSI обеспечивает управление сеансом связи?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Сеансовый", "Канальный"],
    "correct": "C",
    "comment": "Сеансовый уровень (5) управляет установлением, поддержанием и завершением сеансов между приложениями (например, синхронизация, восстановление после сбоя)."
  },
  {
    "text": "Что такое подсеть?",
    "type": "choice",
    "options": ["Часть IP-сети, выделенная с помощью маски подсети", "Группа устройств с одинаковым MAC-адресом", "Тип маршрутизатора", "Протокол для передачи файлов"],
    "correct": "A",
    "comment": "Подсеть — логическое выделение части IP-адресного пространства с помощью маски подсети. Позволяет эффективно использовать адреса и управлять трафиком."
  },
  {
    "text": "Какие протоколы работают на транспортном уровне?",
    "type": "choice",
    "options": ["TCP", "UDP", "IP", "ICMP"],
    "correct": "A, B",
    "comment": "TCP и UDP — основные протоколы транспортного уровня (4). IP и ICMP — сетевого уровня (3)."
  },
  {
    "text": "Что означает маска подсети 255.255.255.128?",
    "type": "choice",
    "options": ["/24", "/25", "/26", "/27"],
    "correct": "B",
    "comment": "255.255.255.128 в двоичном виде: 11111111.11111111.11111111.10000000 → 25 единиц → /25. Это даёт 128 адресов (126 для хостов)."
  },
  {
    "text": "На каком уровне модели OSI работает протокол SNMP?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Прикладной", "Канальный"],
    "correct": "C",
    "comment": "SNMP (Simple Network Management Protocol) используется для управления сетевыми устройствами и предоставляет сервис приложениям — это прикладной уровень (7)."
  },
  {
    "text": "Какой IP-адрес является петлевым (loopback)?",
    "type": "choice",
    "options": ["0.0.0.0", "127.0.0.1", "255.255.255.255", "169.254.1.1"],
    "correct": "B",
    "comment": "127.0.0.1 — стандартный петлевой адрес, используемый для обращения к самому себе. Диапазон 127.0.0.0/8 зарезервирован для loopback."
  },
  {
    "text": "Что такое маршрутизация?",
    "type": "choice",
    "options": ["Пересылка кадров по MAC-адресу", "Выбор пути для пакетов между сетями", "Назначение IP-адресов", "Шифрование трафика"],
    "correct": "B",
    "comment": "Маршрутизация — процесс определения оптимального пути для пакета от источника к получателю через промежуточные сети. Выполняется маршрутизаторами на основе таблиц."
  },
  {
    "text": "Какой протокол использует порт 80?",
    "type": "choice",
    "options": ["HTTPS", "HTTP", "FTP", "SSH"],
    "correct": "B",
    "comment": "HTTP (гипертекстовый протокол) использует порт 80 по умолчанию. HTTPS — 443, FTP — 21, SSH — 22."
  },
  {
    "text": "Какие утверждения верны для IP-адресации версии 4?",
    "type": "choice",
    "options": ["Использует 32-битные адреса", "Предоставляет около 4.3 миллиарда уникальных адресов", "Адрес записывается в десятичной точечной нотации", "Не поддерживает частные адреса"],
    "correct": "A, B, C",
    "comment": "IPv4 — 32 бита, ~4.3 млрд адресов, запись вида 192.168.1.1. Частные адреса поддерживаются (RFC 1918), поэтому D — неверно."
  },
  {
    "text": "Что такое MTU в контексте IP?",
    "type": "choice",
    "options": ["Минимальный размер пакета", "Максимальный размер единицы передачи (пакета)", "Тип кодировки", "Протокол маршрутизации"],
    "correct": "B",
    "comment": "MTU (Maximum Transmission Unit) — максимальный размер пакета, который может быть передан по каналу без фрагментации. Для Ethernet — 1500 байт."
  },
  {
    "text": "На каком уровне модели OSI работает протокол FTP?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Прикладной", "Канальный"],
    "correct": "C",
    "comment": "FTP (File Transfer Protocol) предоставляет сервис передачи файлов — это прикладной уровень (7)."
  },
  {
    "text": "Что такое широковещательный адрес?",
    "type": "choice",
    "options": ["Адрес, назначенный DHCP-сервером", "Адрес, куда отправляются пакеты для всех хостов в подсети", "IP-адрес маршрутизатора", "MAC-адрес коммутатора"],
    "correct": "B",
    "comment": "Широковещательный адрес (например, 192.168.1.255 в /24) используется для отправки пакета всем хостам в подсети. Коммутаторы и хосты обрабатывают такие пакеты."
  },
  {
    "text": "Какой уровень модели OSI отвечает за представление данных (кодировка, шифрование)?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Сеансовый", "Представительский"],
    "correct": "D",
    "comment": "Представительский уровень (6) преобразует данные в формат, понятный приложению: сжатие, шифрование, кодировка (ASCII, UTF-8)."
  },
  {
    "text": "Что такое DHCP-сервер?",
    "type": "choice",
    "options": ["Сервер, преобразующий имена в IP-адреса", "Сервер, автоматически назначающий IP-адреса клиентам", "Сервер для проверки связи", "Сервер для шифрования трафика"],
    "correct": "B",
    "comment": "DHCP-сервер выдаёт клиентам IP-адрес, маску, шлюз, DNS автоматически, упрощая администрирование сети."
  },
  {
    "text": "Какой IP-адрес используется как источник при отправке пакета с APIPA?",
    "type": "choice",
    "options": ["192.168.1.1", "10.0.0.1", "169.254.x.x", "127.0.0.1"],
    "correct": "C",
    "comment": "При отсутствии DHCP Windows назначает адрес из 169.254.0.0/16 — это APIPA. Такой адрес работает только в локальном сегменте."
  },
  {
    "text": "Что такое фрагментация IP-пакета?",
    "type": "choice",
    "options": ["Разделение большого пакета на части для передачи по каналу с малым MTU", "Шифрование пакета на части", "Объединение нескольких пакетов в один", "Удаление заголовка пакета"],
    "correct": "A",
    "comment": "Если пакет больше MTU канала, маршрутизатор фрагментирует его на части. Получатель собирает фрагменты обратно. Это снижает производительность, поэтому стараются избегать."
  },
  {
    "text": "На каком уровне модели OSI работает протокол Telnet?",
    "type": "choice",
    "options": ["Сетевой", "Транспортный", "Прикладной", "Физический"],
    "correct": "C",
    "comment": "Telnet — протокол для удалённого управления, предоставляет сервис приложению — прикладной уровень (7)."
  },
  {
    "text": "Какой протокол использует порт 22?",
    "type": "choice",
    "options": ["FTP", "SSH", "HTTP", "DNS"],
    "correct": "B",
    "comment": "SSH (Secure Shell) использует порт 22 для защищённого удалённого доступа. FTP — 21, HTTP — 80, DNS — 53."
  },
  {
    "text": "Какие утверждения верны для модели OSI?",
    "type": "choice",
    "options": ["Состоит из 7 уровней", "Уровни изолированы и взаимодействуют только с соседними", "Используется как эталонная модель для понимания сетевых протоколов", "Все протоколы интернета строго следуют модели OSI"],
    "correct": "A, B, C",
    "comment": "Модель OSI — теоретическая, с 7 уровнями, где каждый взаимодействует только с соседними. Она помогает понимать сети, но реальный стек TCP/IP не следует ей строго (например, нет отдельных сеансового и представительского уровней). Поэтому D — неверно."
  },
  {
    "text": "Что такое публичный DNS-сервер?",
    "type": "choice",
    "options": ["Сервер, доступный только в локальной сети", "Сервер, преобразующий доменные имена в IP-адреса и доступный из интернета", "Сервер для хранения веб-страниц", "Устройство для маршрутизации"],
    "correct": "B",
    "comment": "Публичные DNS-серверы (например, 8.8.8.8 от Google, 1.1.1.1 от Cloudflare) предоставляют услугу разрешения имён любому пользователю в интернете."
  },
  {
    "text": "Какой уровень модели OSI обеспечивает обнаружение и исправление ошибок в кадрах?",
    "type": "choice",
    "options": ["Физический", "Канальный", "Сетевой", "Транспортный"],
    "correct": "B",
    "comment": "Канальный уровень (2) добавляет CRC (циклический избыточный код) в кадр для обнаружения ошибок. Исправление обычно не выполняется — повреждённый кадр отбрасывается."
  },
  {
    "text": "Что такое IPv6?",
    "type": "choice",
    "options": ["Протокол для шифрования трафика", "Версия IP с 128-битными адресами", "Тип сетевого кабеля", "Устройство для подключения к интернету"],
    "correct": "B",
    "comment": "IPv6 использует 128-битные адреса (например, 2001:0db8::1), что даёт огромное адресное пространство (~3.4×10³⁸ адресов) и решает проблему исчерпания IPv4."
  }
],

  "type_11": [
  {
    "text": "Какая архитектура ядра использует минимальное количество функций в привилегированном режиме?",
    "type": "choice",
    "options": ["Монолитное ядро", "Микроядро", "Гибридное ядро", "Наноядро"],
    "correct": "D",
    "comment": "Наноядро — это ультраминималистичная архитектура, где в режиме ядра остаются только базовые функции: управление памятью, планирование потоков и межпроцессное взаимодействие (IPC). Всё остальное (драйверы, файловые системы, сетевой стек) работает в пользовательском пространстве. Это делает ядро крайне компактным и надёжным, так как сбой в драйвере не приводит к падению всей системы. Микроядро (B) тоже минималистично, но обычно включает больше функций, чем наноядро. Монолитное (A) — наоборот, содержит всё в ядре."
  },
  {
    "text": "Какое утверждение верно для монолитного ядра?",
    "type": "choice",
    "options": ["Драйверы устройств работают в пользовательском режиме", "Все основные функции ОС работают в одном адресном пространстве ядра", "Сбой драйвера не влияет на стабильность системы", "Используется в macOS и Windows NT"],
    "correct": "B",
    "comment": "В монолитном ядре (например, Linux, traditional Unix) все компоненты — планировщик, драйверы, файловые системы, сетевой стек — компилируются в единый исполняемый модуль, работающий в привилегированном режиме (ring 0) и в одном адресном пространстве. Это обеспечивает высокую производительность (нет переключений между режимами), но снижает надёжность: сбой в любом модуле (например, в драйвере) вызывает падение всей системы (kernel panic, BSOD). Вариант A описывает микроядро, C — его преимущество, D — гибридную архитектуру."
  },
  {
    "text": "Какие утверждения верны для микроядра?",
    "type": "choice",
    "options": ["Драйверы устройств работают в пользовательском режиме", "Меньше надёжность при сбое драйвера", "Больше накладных расходов из-за межпроцессного взаимодействия (IPC)", "Используется в Linux"],
    "correct": "A, C",
    "comment": "Микроядро (например, QNX, Minix 3, L4) выносит все несущественные сервисы (драйверы, файловые системы, сетевой стек) в пользовательское пространство как отдельные процессы. Это повышает надёжность: сбой драйвера не убивает ядро — его можно перезапустить. Однако обмен данными между компонентами требует частых IPC-вызовов, что создаёт значительные накладные расходы и снижает производительность. Linux использует монолитное ядро (D — неверно), а надёжность при сбое выше, а не ниже (B — неверно)."
  },
  {
    "text": "Какая ОС использует монолитное ядро?",
    "type": "choice",
    "options": ["Windows 10", "macOS", "Linux", "QNX"],
    "correct": "C",
    "comment": "Linux — классический пример монолитного ядра: все функции работают в режиме ядра. Windows NT (основа Windows 10) и macOS XNU используют гибридную архитектуру. QNX — чистое микроядро, разработанное для встроенных систем и автомобилей. Типичная ошибка — считать, что все современные ОС используют микроядра, но на практике монолитные и гибридные доминируют из-за производительности."
  },
  {
    "text": "Что такое гибридное ядро?",
    "type": "choice",
    "options": ["Ядро, сочетающее черты монолитного и микроядра", "Ядро, работающее только в облаке", "Ядро без поддержки многопоточности", "Ядро, написанное на нескольких языках"],
    "correct": "A",
    "comment": "Гибридное ядро — это компромисс между производительностью монолитного и надёжностью микроядра. Оно сохраняет критически важные компоненты (например, драйверы, планировщик) в пространстве ядра для скорости, но выносит менее критичные (например, некоторые серверы) в пользовательское пространство. Примеры: XNU (macOS, iOS) — микроядро Mach + монолитная BSD-часть; Windows NT kernel — микроядро Executive + монолитные подсистемы. Это позволяет достичь баланса, хотя чистота архитектуры страдает."
  },
  {
    "text": "Какие утверждения верны для наноядра?",
    "type": "choice",
    "options": ["Содержит только базовые примитивы: IPC, управление памятью, планирование", "Используется в высоконадёжных системах (авиация, медицина)", "Имеет самые низкие накладные расходы среди всех типов ядер", "Драйверы работают в режиме ядра"],
    "correct": "A, B",
    "comment": "Наноядро (например, seL4, EROS) используется там, где критична надёжность и безопасность: авионика, автомобильные системы, военные проекты. Оно не имеет самых низких накладных расходов — наоборот, из-за постоянного IPC они высоки. Драйверы работают в пользовательском режиме, а не в ядре."
  },
  {
    "text": "Почему монолитное ядро быстрее микроядра?",
    "type": "choice",
    "options": ["Потому что не использует драйверы", "Потому что все вызовы функций происходят внутри одного адресного пространства", "Потому что не поддерживает многопоточность", "Потому что работает только в 32-битном режиме"],
    "correct": "B",
    "comment": "В монолитном ядре вызов функции (например, чтение файла) — это просто переход по адресу в том же пространстве. В микроядре тот же вызов требует IPC: переключение контекста, проверку прав, передачу данных через ядро — это дорого. Поэтому монолитное ядро быстрее, особенно при интенсивном взаимодействии компонентов."
  },
  {
    "text": "Какая ОС использует микроядро?",
    "type": "choice",
    "options": ["Linux", "Windows 11", "QNX", "Android"],
    "correct": "C",
    "comment": "QNX — ре-time ОС с чистым микроядром, используется в автомобилях (Blackberry), медицинских устройствах. Linux — монолитное, Windows — гибридное, Android — основан на Linux, поэтому тоже монолитное."
  },
  {
    "text": "Что происходит при сбое драйвера в микроядре?",
    "type": "choice",
    "options": ["Вся система зависает", "Происходит перезагрузка", "Драйвер можно перезапустить без перезагрузки системы", "Автоматически загружается резервный драйвер"],
    "correct": "C",
    "comment": "Поскольку драйвер работает как отдельный процесс в пользовательском режиме, его сбой не затрагивает ядро. Менеджер драйверов может завершить аварийный процесс и запустить новый — без перезагрузки. Это ключевое преимущество микроядер в embedded-системах."
  },
  {
    "text": "Какие компоненты обычно входят в монолитное ядро?",
    "type": "choice",
    "options": ["Драйверы устройств", "Файловые системы", "Сетевой стек", "Графическая подсистема"],
    "correct": "A, B, C",
    "comment": "В классическом монолитном ядре драйверы, файловые системы и сетевой стек компилируются в ядро. Графическая подсистема (D) в Linux работает в пользовательском пространстве (X Server, Wayland), хотя в Windows драйверы графики часто в ядре (гибридная модель)."
  },
  {
    "text": "Какая архитектура ядра использована в Windows NT?",
    "type": "choice",
    "options": ["Монолитное ядро", "Микроядро", "Гибридное ядро", "Наноядро"],
    "correct": "C",
    "comment": "Windows NT использует гибридное ядро: Executive (включает диспетчер объектов, диспетчер процессов, диспетчер виртуальной памяти) работает в режиме ядра, но некоторые компоненты (например, CSRSS — подсистема Win32) — в пользовательском пространстве. Это позволяет балансировать между скоростью и стабильностью."
  },
  {
    "text": "Какие утверждения верны для гибридного ядра?",
    "type": "choice",
    "options": ["Часть сервисов работает в пространстве ядра, часть — в пользовательском", "Пытается совместить преимущества монолитного и микроядра", "Используется в macOS и Windows", "Не поддерживает драйверы устройств"],
    "correct": "A, B, C",
    "comment": "Гибридное ядро — это практический компромисс. macOS (XNU = Mach + BSD) и Windows (NT kernel) используют его, чтобы получить и скорость (монолит), и некоторую изоляцию (микроядро). Драйверы поддерживаются и даже часто работают в ядре для производительности."
  },
  {
    "text": "Что такое Mach в контексте macOS?",
    "type": "choice",
    "options": ["Монолитное ядро", "Микроядро, являющееся основой XNU", "Драйвер видеокарты", "Файловая система"],
    "correct": "B",
    "comment": "XNU (X is Not Unix) — ядро macOS/iOS. Оно состоит из микроядра Mach (управление памятью, IPC, планирование) и монолитной BSD-подсистемы (файловые системы, сетевой стек, POSIX API). Mach обеспечивает низкоуровневые примитивы, а BSD — совместимость с Unix."
  },
  {
    "text": "Почему микроядра historically были медленнее монолитных?",
    "type": "choice",
    "options": ["Потому что использовали устаревшие алгоритмы", "Из-за высоких накладных расходов на межпроцессное взаимодействие (IPC)", "Потому что не поддерживали многопроцессорность", "Из-за отсутствия кэширования"],
    "correct": "B",
    "comment": "В 1990-х годах исследования (например, Liedtke) показали, что IPC в микроядрах того времени был в 10–100 раз медленнее вызова функции в монолитном ядре. Современные микроядра (L4, seL4) оптимизировали IPC до приемлемого уровня, но исторически это было главным аргументом против них."
  },
  {
    "text": "Какая ОС была разработана как реакция на недостатки монолитного ядра UNIX?",
    "type": "choice",
    "options": ["Linux", "Minix", "Windows 95", "DOS"],
    "correct": "B",
    "comment": "Эндрю Таненбаум создал Minix как учебную ОС с микроядром, чтобы показать, что UNIX (монолитный) архитектурно устарел. Это вызвало знаменитую переписку с Линусом Торвальдсом, который defended монолитное ядро Linux как более практичное."
  },
  {
    "text": "Какие преимущества у монолитного ядра?",
    "type": "choice",
    "options": ["Высокая производительность", "Простота разработки модулей", "Легкость отладки", "Надёжность при сбое драйвера"],
    "correct": "A, B",
    "comment": "Монолитное ядро быстрое (A) и проще в разработке (B), так как модули имеют прямой доступ ко всем структурам ядра. Но отладка сложна (C — неверно), а надёжность низка (D — неверно): сбой в модуле = падение системы."
  },
  {
    "text": "Что такое L4?",
    "type": "choice",
    "options": ["Файловая система", "Микроядро второго поколения с высокой производительностью IPC", "Драйвер сетевой карты", "Версия Linux"],
    "correct": "B",
    "comment": "L4 — семейство микроядер, разработанных Йенсом Лидтке (Jochen Liedtke) в 1990-х. Они радикально оптимизировали IPC, сделав микроядра конкурентоспособными по скорости. На базе L4 построены seL4 (с формальной верификацией безопасности) и другие high-assurance системы."
  },
  {
    "text": "Какой уровень привилегий использует ядро в архитектуре x86?",
    "type": "choice",
    "options": ["Ring 0", "Ring 1", "Ring 2", "Ring 3"],
    "correct": "A",
    "comment": "В x86 есть 4 уровня привилегий (ring 0–3). Ring 0 — самый привилегированный, используется ядром ОС. Ring 3 — пользовательские приложения. Драйверы в монолитном ядре тоже работают в ring 0, в микроядре — в ring 3."
  },
  {
    "text": "Какие недостатки у микроядра?",
    "type": "choice",
    "options": ["Высокие накладные расходы на IPC", "Сложность разработки и отладки", "Низкая производительность при интенсивном взаимодействии компонентов", "Большой размер ядра"],
    "correct": "A, B, C",
    "comment": "Микроядро маленькое (D — неверно), но IPC делает его медленным (A, C), а распределённая природа усложняет разработку (B). Это причины, по которым оно редко используется на рабочих станциях."
  },
  {
    "text": "Что такое seL4?",
    "type": "choice",
    "options": ["Монолитное ядро Linux", "Микроядро с формально доказанной безопасностью", "Графическая оболочка Windows", "Протокол передачи данных"],
    "correct": "B",
    "comment": "seL4 — микроядро, разработанное NICTA (Австралия). Его код формально верифицирован: математически доказано, что он соответствует спецификации и не содержит уязвимостей типа buffer overflow. Используется в критических системах."
  },
  {
    "text": "Какая архитектура ядра использована в Android?",
    "type": "choice",
    "options": ["Микроядро", "Монолитное ядро", "Гибридное ядро", "Наноядро"],
    "correct": "B",
    "comment": "Android основан на Linux, который имеет монолитное ядро. Хотя в Android есть пользовательские сервисы (например, SurfaceFlinger), само ядро — монолитное."
  },
  {
    "text": "Что такое «пространство ядра»?",
    "type": "choice",
    "options": ["Область памяти, доступная только ядру ОС", "Папка на диске с файлами ядра", "Виртуальная машина для запуска драйверов", "Сетевой интерфейс ядра"],
    "correct": "A",
    "comment": "Пространство ядра — это защищённая область памяти, доступная только в привилегированном режиме (ring 0). Пользовательские приложения (ring 3) не могут читать или писать туда напрямую. Это обеспечивает безопасность и стабильность."
  },
  {
    "text": "Какие утверждения верны для драйверов в монолитном ядре?",
    "type": "choice",
    "options": ["Работают в пространстве ядра", "Имеют прямой доступ к аппаратным ресурсам", "Их сбой может привести к падению системы", "Запускаются как отдельные процессы"],
    "correct": "A, B, C",
    "comment": "В монолитном ядре драйверы — это модули, загружаемые в пространство ядра (A). Они имеют полный доступ к железу (B), но их ошибка вызывает BSOD (C). В микроядре они работают как процессы (D), но не в монолитном."
  },
  {
    "text": "Что такое «пользовательское пространство»?",
    "type": "choice",
    "options": ["Область памяти, где работают приложения и некоторые сервисы ОС", "Папка «Пользователи» на диске", "Облачное хранилище", "Интерфейс командной строки"],
    "correct": "A",
    "comment": "Пользовательское пространство — это непривилегированная область памяти, где работают приложения и (в микроядре) драйверы/файловые системы. Доступ к оборудованию возможен только через системные вызовы в ядро."
  },
  {
    "text": "Какая ОС использует гибридное ядро XNU?",
    "type": "choice",
    "options": ["Linux", "Windows", "macOS", "FreeBSD"],
    "correct": "C",
    "comment": "XNU (X is Not Unix) — ядро macOS и iOS. Оно объединяет микроядро Mach и монолитную BSD-подсистему, что делает его гибридным."
  },
  {
    "text": "Почему гибридные ядра популярны в коммерческих ОС?",
    "type": "choice",
    "options": ["Потому что они самые маленькие", "Потому что обеспечивают баланс между производительностью и надёжностью", "Потому что легко портируются на любую архитектуру", "Потому что не требуют драйверов"],
    "correct": "B",
    "comment": "Чистые микроядра слишком медленны для desktop-систем, монолитные — недостаточно надёжны. Гибридные (Windows, macOS) берут лучшее из обоих миров: критические компоненты в ядре для скорости, менее критичные — вне ядра для изоляции."
  },
  {
    "text": "Какие компоненты работают в пользовательском пространстве в микроядре?",
    "type": "choice",
    "options": ["Драйверы устройств", "Файловые системы", "Сетевой стек", "Планировщик процессов"],
    "correct": "A, B, C",
    "comment": "В микроядре только минимальный набор (IPC, управление памятью, планировщик) остаётся в ядре. Драйверы, файловые системы, сетевой стек — всё это пользовательские процессы. Планировщик (D) — часть ядра."
  },
  {
    "text": "Что такое «системный вызов»?",
    "type": "choice",
    "options": ["Вызов функции из библиотеки приложения", "Механизм перехода из пользовательского режима в режим ядра", "Ошибка в программе", "Команда в терминале"],
    "correct": "B",
    "comment": "Системный вызов (syscall) — это контролируемый способ для приложения запросить услугу у ядра (чтение файла, выделение памяти). Процессор переключается из ring 3 в ring 0, ядро проверяет права и выполняет операцию."
  },
  {
    "text": "Какая архитектура ядра наиболее подходит для встроенных систем с жёсткими требованиями к надёжности?",
    "type": "choice",
    "options": ["Монолитное ядро", "Микроядро", "Гибридное ядро", "Наноядро"],
    "correct": "D",
    "comment": "Для систем, где недопустимы сбои (авионика, медицинские импланты, АЭС), используется наноядро (например, seL4). Его код формально верифицирован, а изоляция компонентов гарантирует, что сбой в одном модуле не повлияет на другие. Микроядро (B) тоже надёжно, но наноядро ещё минималистичнее и безопаснее."
  },
  {
    "text": "Что такое «модуль ядра» в Linux?",
    "type": "choice",
    "options": ["Приложение, работающее в фоне", "Динамически загружаемый компонент монолитного ядра", "Отдельный процесс в пользовательском пространстве", "Файл конфигурации ОС"],
    "correct": "B",
    "comment": "В Linux (монолитное ядро) драйверы и файловые системы могут быть скомпилированы как модули (.ko) и загружены в ядро динамически командой `insmod`. Они работают в пространстве ядра, поэтому их сбой вызывает kernel panic. Это не процессы (C), а часть ядра."
  },
  {
    "text": "Какие утверждения верны для гибридного ядра Windows NT?",
    "type": "choice",
    "options": ["Executive работает в режиме ядра", "Подсистема Win32 (CSRSS) работает в пользовательском режиме", "Драйверы устройств всегда работают в пользовательском режиме", "Использует микроядерные принципы для базовых сервисов"],
    "correct": "A, B, D",
    "comment": "В Windows NT Executive (ядро) содержит диспетчер объектов, памяти, процессов — всё в ring 0 (A). CSRSS — пользовательский процесс, реализующий Win32 API (B). Драйверы (особенно уровня kernel-mode) работают в ядре для производительности (C — неверно). Архитектура вдохновлена микроядрами (D)."
  },
  {
    "text": "Почему монолитное ядро проще отлаживать на ранних этапах разработки?",
    "type": "choice",
    "options": ["Потому что не требует аппаратуры", "Потому что все компоненты доступны в одном адресном пространстве", "Потому что не использует прерывания", "Потому что работает только в эмуляторе"],
    "correct": "B",
    "comment": "При отладке монолитного ядра можно поставить точку останова в любом модуле, так как всё находится в одном адресном пространстве. В микроядре нужно отлаживать множество независимых процессов, что сложнее."
  },
  {
    "text": "Какая ОС использует микроядро Mach в своей основе?",
    "type": "choice",
    "options": ["Linux", "Windows", "macOS", "Android"],
    "correct": "C",
    "comment": "Ядро macOS — XNU, которое состоит из микроядра Mach и BSD-слоя. Mach отвечает за низкоуровневые операции (IPC, память), BSD — за POSIX-совместимость. Это делает XNU гибридным, но Mach — его микроядерная основа."
  },
  {
    "text": "Что такое «ring 3» в архитектуре x86?",
    "type": "choice",
    "options": ["Режим ядра", "Пользовательский режим", "Режим гипервизора", "Режим BIOS"],
    "correct": "B",
    "comment": "В x86 ring 0 — ядро (максимальные привилегии), ring 3 — пользовательские приложения (минимальные привилегии). Rings 1 и 2 исторически использовались для драйверов, но в современных ОС почти не применяются."
  },
  {
    "text": "Какие недостатки у монолитного ядра?",
    "type": "choice",
    "options": ["Низкая надёжность: сбой модуля = падение системы", "Сложность добавления новых функций без перекомпиляции ядра", "Большой размер образа ядра", "Высокие накладные расходы на IPC"],
    "correct": "A, B, C",
    "comment": "Монолитное ядро страдает от низкой отказоустойчивости (A), необходимости перекомпиляции при изменении (B) и большого размера (C). IPC используется мало, поэтому D — неверно (это проблема микроядер)."
  },
  {
    "text": "Что такое «Executive» в Windows NT?",
    "type": "choice",
    "options": ["Пользовательский интерфейс", "Ядро гибридной архитектуры, работающее в ring 0", "Диспетчер задач", "Служба обновления Windows"],
    "correct": "B",
    "comment": "Executive — это ядро Windows NT, содержащее диспетчер объектов, памяти, процессов, ввода-вывода. Он работает в режиме ядра (ring 0) и является частью гибридной архитектуры."
  },
  {
    "text": "Какие утверждения верны для наноядра seL4?",
    "type": "choice",
    "options": ["Имеет формально верифицированный код", "Гарантирует изоляцию между компонентами", "Используется в коммерческих смартфонах", "Работает только на ARM-архитектуре"],
    "correct": "A, B",
    "comment": "seL4 — первое ОС-ядро с математически доказанной корректностью. Оно гарантирует, что компоненты не могут мешать друг другу. Оно используется в военных, авиационных и автомобильных системах, но не в смартфонах (C — неверно). Поддерживает x86 и ARM (D — неверно)."
  },
  {
    "text": "Что такое «monolithic kernel» на русском?",
    "type": "choice",
    "options": ["Микроядро", "Монолитное ядро", "Гибридное ядро", "Наноядро"],
    "correct": "B",
    "comment": "«Monolithic» означает «единый, неразделимый». Монолитное ядро — это единый исполняемый образ, содержащий все функции ОС."
  },
  {
    "text": "Какой принцип лежит в основе микроядра?",
    "type": "choice",
    "options": ["Минимализм: только необходимые функции в ядре", "Максимализм: всё в ядре для скорости", "Распределённость: ядро работает на нескольких серверах", "Виртуализация: каждый процесс — виртуальная машина"],
    "correct": "A",
    "comment": "Микроядро следует принципу минимализма: в привилегированном режиме остаётся только то, что невозможно реализовать в пользовательском пространстве. Всё остальное — как сервисы."
  },
  {
    "text": "Какая ОС использует микроядро в качестве основы для своих embedded-решений?",
    "type": "choice",
    "options": ["Linux", "Windows IoT", "QNX", "Android Things"],
    "correct": "C",
    "comment": "QNX — это ОС реального времени с чистым микроядром, широко используемая в автомобильной промышленности (BlackBerry QNX), медицинских устройствах и промышленных контроллерах."
  },
  {
    "text": "Что такое «kernel space»?",
    "type": "choice",
    "options": ["Папка /kernel в файловой системе", "Область памяти с высокими привилегиями, доступная только ядру", "Виртуальная машина для тестирования драйверов", "Сетевой протокол ядра"],
    "correct": "B",
    "comment": "Kernel space — это защищённая область памяти, где работает ядро. Пользовательские приложения не могут туда писать, что предотвращает повреждение системы."
  },
  {
    "text": "Какие утверждения верны для гибридного ядра?",
    "type": "choice",
    "options": ["Может включать элементы микроядра и монолитного ядра", "Часто используется в современных desktop-ОС", "Обеспечивает лучший баланс для общего назначения", "Не поддерживает многопроцессорность"],
    "correct": "A, B, C",
    "comment": "Гибридные ядра (Windows, macOS) доминируют на desktop из-за баланса. Они поддерживают многопроцессорность (D — неверно)."
  },
  {
    "text": "Что такое «user space»?",
    "type": "choice",
    "options": ["Область памяти для приложений с ограниченными привилегиями", "Домашняя директория пользователя", "Облачное хранилище", "Режим восстановления ОС"],
    "correct": "A",
    "comment": "User space — это память, где работают приложения. Они взаимодействуют с ядром только через системные вызовы."
  },
  {
    "text": "Какой компонент ядра отвечает за распределение времени CPU между процессами?",
    "type": "choice",
    "options": ["Диспетчер памяти", "Планировщик", "Файловая система", "Сетевой стек"],
    "correct": "B",
    "comment": "Планировщик (scheduler) решает, какой процесс будет выполняться следующим, и на сколько времени. Это ключевой компонент любого ядра."
  },
  {
    "text": "В какой архитектуре ядра сбой файловой системы не приведёт к падению всей ОС?",
    "type": "choice",
    "options": ["Монолитное ядро", "Микроядро", "Гибридное ядро", "Все вышеперечисленные"],
    "correct": "B",
    "comment": "В микроядре файловая система — отдельный процесс в пользовательском пространстве. Её сбой не затрагивает ядро — её можно перезапустить. В монолитном и гибридном (если ФС в ядре) — система упадёт."
  },
  {
    "text": "Что такое «system call interface»?",
    "type": "choice",
    "options": ["API для взаимодействия приложений с ядром", "Графический интерфейс диспетчера задач", "Протокол обмена между ядрами в SMP", "Интерфейс для загрузки модулей"],
    "correct": "A",
    "comment": "System call interface — это набор функций (например, `read`, `write`, `fork` в Unix), через которые приложения запрашивают услуги у ядра."
  },
  {
    "text": "Какие утверждения верны для монолитного ядра Linux?",
    "type": "choice",
    "options": ["Поддерживает загрузку модулей во время выполнения", "Драйверы могут быть частью ядра или модулем", "Сбой модуля вызывает kernel panic", "Все компоненты всегда компилируются в ядро"],
    "correct": "A, B, C",
    "comment": "Linux позволяет компилировать компоненты либо в ядро, либо как модули (B, D — неверно, так как не «всегда»). Модули можно загружать динамически (A), но их сбой = kernel panic (C)."
  },
  {
    "text": "Что такое «microkernel» на русском?",
    "type": "choice",
    "options": ["Монолитное ядро", "Микроядро", "Гибридное ядро", "Наноядро"],
    "correct": "B",
    "comment": "Microkernel — это «микроядро», архитектура с минимальным набором функций в привилегированном режиме."
  },
  {
    "text": "Какая архитектура ядра обеспечивает наивысшую производительность при работе с дисковой подсистемой?",
    "type": "choice",
    "options": ["Микроядро", "Монолитное ядро", "Наноядро", "Все одинаковы"],
    "correct": "B",
    "comment": "В монолитном ядре драйвер диска и файловая система работают в одном адресном пространстве, что минимизирует накладные расходы. В микроядре каждый запрос требует IPC — это медленнее."
  },
  {
    "text": "Что такое «hybrid kernel»?",
    "type": "choice",
    "options": ["Ядро, сочетающее подходы монолитного и микроядра", "Ядро для гибридных облаков", "Ядро с поддержкой гибридных дисков", "Ядро, написанное на C и Rust"],
    "correct": "A",
    "comment": "Hybrid kernel — это архитектура, которая пытается получить преимущества обоих миров: скорость монолитного и надёжность микроядра. Примеры: Windows NT, XNU (macOS)."
  }
],

  "type_12": [
  {
    "text": "Является ли безопасным хранение паролей в браузере?",
    "type": "choice",
    "options": ["Да, потому что браузер шифрует их", "Нет, потому что любой, кто получит физический доступ к устройству, может их увидеть", "Да, если включена двухфакторная аутентификация", "Нет, потому что браузер не имеет защиты от кейлоггеров"],
    "correct": "B",
    "comment": "Современные браузеры действительно шифруют сохранённые пароли, но ключ шифрования часто хранится на том же устройстве и защищён только учётной записью Windows или мастер-паролем (в Firefox). Если злоумышленник получает физический доступ к компьютеру и может войти в систему (или сбросить пароль), он легко экспортирует все пароли через настройки браузера. Двухфакторная аутентификация (C) защищает учётную запись онлайн, но не локальное хранилище. Кейлоггеры (D) — отдельная угроза, но даже без них пароли уязвимы при физическом доступе. Поэтому B — наиболее точный и общий ответ."
  },
  {
    "text": "Какая угроза относится к пассивным атакам?",
    "type": "choice",
    "options": ["Подмена ARP-таблицы", "Перехват сетевого трафика с помощью Wireshark", "Атака типа «отказ в обслуживании» (DoS)", "Установка трояна на устройство"],
    "correct": "B",
    "comment": "Пассивная атака — это наблюдение за системой без вмешательства в её работу. Злоумышленник просто слушает трафик (например, через сниффер Wireshark), чтобы украсть данные (логины, пароли, содержимое писем). Он не изменяет, не блокирует и не подделывает данные. Варианты A (ARP spoofing), C (DoS) и D (троян) — это активные атаки, так как они вмешиваются в работу системы: подменяют адреса, перегружают сервер или внедряют вредоносный код. Основная цель пассивной атаки — конфиденциальность, а не целостность или доступность."
  },
  {
    "text": "Что такое фишинг?",
    "type": "choice",
    "options": ["Взлом Wi-Fi сети", "Использование слабых паролей", "Обман пользователя с целью получения конфиденциальной информации", "Перехват SMS-кодов"],
    "correct": "C",
    "comment": "Фишинг — это социальная инженерия, при которой злоумышленник имитирует доверенный источник (банк, почтовый сервис, коллега) через электронную почту, SMS или поддельный сайт, чтобы выманить у жертвы пароли, номера карт, PIN-коды. Например, письмо от «Google» с требованием срочно подтвердить аккаунт, ведущее на фальшивую страницу входа. Вариант D (перехват SMS) — это SIM-swap или SS7-атака, а не фишинг, хотя фишинг может использоваться для получения данных, необходимых для SIM-swap. Фишинг не требует технического взлома — он эксплуатирует доверие человека."
  },
  {
    "text": "Какие из перечисленных угроз являются активными атаками?",
    "type": "choice",
    "options": ["Подмена DNS-ответа", "Перехват трафика через Wireshark", "SYN-flood", "Установка шпиона на устройство"],
    "correct": "A, C, D",
    "comment": "Активная атака предполагает вмешательство в передачу или обработку данных. — A) Подмена DNS — злоумышленник подделывает ответ сервера, направляя жертву на вредоносный сайт (вмешательство в целостность данных). — C) SYN-flood — атака типа DoS, при которой отправляется множество полуоткрытых TCP-соединений, исчерпывающих ресурсы сервера (вмешательство в доступность). — D) Установка шпиона — внедрение ПО, которое активно собирает и передаёт данные (вмешательство в целостность и конфиденциальность). B) Перехват трафика — пассивная атака, так как данные только читаются, но не изменяются."
  },
  {
    "text": "Безопасно ли использовать один и тот же пароль для всех аккаунтов?",
    "type": "choice",
    "options": ["Да, если пароль сложный", "Нет, потому что утечка одного пароля скомпрометирует все аккаунты", "Да, если включена двухфакторная аутентификация", "Нет, потому что пароль будет слишком длинным"],
    "correct": "B",
    "comment": "Даже самый сложный пароль становится бесполезным, если он утекает из одного сервиса (например, при взломе базы данных сайта). Злоумышленник попробует этот же логин/пароль на других популярных платформах (Google, Facebook, банк) — это называется атака по словарю учётных данных (credential stuffing). Двухфакторная аутентификация (C) защищает от использования украденного пароля, но не все сервисы её поддерживают, и она не спасает от фишинга (если жертва введёт и код). Поэтому уникальный пароль для каждого аккаунта — основа безопасности. Вариант D — бессмыслен."
  },
  {
    "text": "Что такое двухфакторная аутентификация (2FA)?",
    "type": "choice",
    "options": ["Использование двух разных паролей", "Подтверждение личности с помощью двух факторов: знание (пароль) и владение (телефон, токен)", "Вход в систему с двух разных устройств", "Шифрование данных двумя ключами"],
    "correct": "B",
    "comment": "2FA повышает безопасность, требуя два независимых подтверждения: 1. Что-то, что вы знаете (пароль, PIN), 2. Что-то, что у вас есть (телефон с приложением Google Authenticator, аппаратный токен YubiKey, SMS-код). Это делает атаку значительно сложнее: даже если пароль украден, злоумышленнику нужен доступ к вашему второму фактору. Вариант A — это просто два пароля, что не даёт реальной защиты. Вариант C — не связано с аутентификацией. Вариант D — описание асимметричного шифрования."
  },
  {
    "text": "Какая угроза возникает при подключении к публичному Wi-Fi без VPN?",
    "type": "choice",
    "options": ["Устройство может быть заражено вирусом автоматически", "Все передаваемые данные могут быть перехвачены", "Интернет будет работать медленнее", "Батарея разрядится быстрее"],
    "correct": "B",
    "comment": "Публичные Wi-Fi сети (в кафе, аэропортах) часто незашифрованы или используют слабое шифрование. Это позволяет злоумышленнику в той же сети использовать снифферы (например, Wireshark) или создавать поддельные точки доступа (evil twin), чтобы перехватывать весь ваш трафик: логины, пароли, банковские операции. Если сайт использует HTTPS, содержимое защищено, но адреса сайтов (DNS-запросы) и метаданные всё равно видны. VPN шифрует весь трафик, предотвращая перехват. Вариант A возможен, но не автоматически — требуется взаимодействие пользователя. C и D — побочные эффекты, но не угрозы безопасности."
  },
  {
    "text": "Что такое кейлоггер?",
    "type": "choice",
    "options": ["Программа для генерации надёжных паролей", "Вредоносное ПО, записывающее нажатия клавиш", "Антивирус для защиты от троянов", "Система двухфакторной аутентификации"],
    "correct": "B",
    "comment": "Кейлоггер (keylogger) — это программа или аппаратное устройство, которое тайно записывает каждое нажатие клавиш на клавиатуре. Это позволяет злоумышленнику получить пароли, сообщения, банковские реквизиты в открытом виде, даже если они вводятся в защищённых полях. Кейлоггеры могут быть программными (в составе троянов) или аппаратными (устройство между клавиатурой и компьютером). Они обходят большинство защит, включая HTTPS и 2FA (если код вводится с клавиатуры). Вариант A — менеджер паролей, C — антивирус, D — 2FA."
  },
  {
    "text": "Какие меры повышают безопасность хранения паролей?",
    "type": "choice",
    "options": ["Использование уникального пароля для каждого аккаунта", "Хранение паролей в зашифрованном менеджере паролей", "Запись паролей в текстовый файл на рабочем столе", "Регулярная смена паролей"],
    "correct": "A, B",
    "comment": "— A) Уникальные пароли предотвращают каскадную компрометацию. — B) Менеджер паролей (Bitwarden, 1Password, KeePass) хранит все пароли в зашифрованном хранилище, защищённом мастер-паролем. Он также генерирует сложные пароли и автозаполняет формы, снижая риск фишинга. — C) Текстовый файл на рабочем столе — крайне небезопасен: доступен любому, кто получит доступ к компьютеру или облачной синхронизации. — D) Регулярная смена паролей не рекомендуется современными стандартами (NIST), если пароль не скомпрометирован. Она часто приводит к предсказуемым паролям (Password1, Password2...)."
  },
  {
    "text": "Что такое атака «человек посередине» (MITM)?",
    "type": "choice",
    "options": ["Перехват трафика между двумя сторонами с возможностью его изменения", "Взлом пароля методом перебора", "Отправка спама от имени жертвы", "Удалённое управление компьютером"],
    "correct": "A",
    "comment": "MITM (Man-in-the-Middle) — это атака, при которой злоумышленник встаёт между двумя легитимными участниками (например, пользователем и банком) и перехватывает, читает, а иногда и изменяет сообщения в реальном времени, оставаясь незамеченным. Это возможно в незащищённых сетях (публичный Wi-Fi) или при подмене сертификатов. HTTPS с правильной проверкой сертификатов защищает от MITM, но если пользователь игнорирует предупреждения браузера — защита обходится. Варианты B, C, D — другие типы атак."
  },
  {
    "text": "Почему использование простых паролей (например, «123456») опасно?",
    "type": "choice",
    "options": ["Потому что они легко запоминаются", "Потому что они быстро подбираются методом перебора", "Потому что они занимают мало места в памяти", "Потому что они не работают в новых системах"],
    "correct": "B",
    "comment": "Простые пароли находятся в словарях для брутфорса и подбираются за секунды. Современные GPU могут перебирать миллиарды комбинаций в секунду. Даже если система ограничивает попытки входа, утечка хэшей из базы данных позволяет проводить офлайн-брутфорс без ограничений. Вариант A — преимущество для пользователя, но недостаток для безопасности. C и D — не имеют отношения к угрозе."
  },
  {
    "text": "Что такое социальная инженерия?",
    "type": "choice",
    "options": ["Использование уязвимостей в программном обеспечении", "Манипуляция людьми для получения конфиденциальной информации", "Шифрование данных с помощью социальных сетей", "Создание вирусов через социальные сети"],
    "correct": "B",
    "comment": "Социальная инженерия — это психологическая атака, направленная на эксплуатацию человеческого фактора, а не технических уязвимостей. Злоумышленник вызывает доверие, страх или срочность, чтобы заставить жертву раскрыть информацию, перевести деньги или установить вредоносное ПО. Примеры: звонок от «техподдержки Microsoft», письмо от «начальника» с просьбой срочно оплатить счёт, фишинговые письма. Это одна из самых эффективных техник, так как люди — самое слабое звено в цепи безопасности."
  },
  {
    "text": "Какие действия защищают от фишинга?",
    "type": "choice",
    "options": ["Проверка URL перед вводом пароля", "Использование менеджера паролей", "Открытие всех писем от неизвестных отправителей", "Игнорирование предупреждений браузера о небезопасном сайте"],
    "correct": "A",
    "comment": "— A) Проверка URL — фишинговые сайты часто используют похожие домены (paypa1.com вместо paypal.com). Внимательный взгляд на адресную строку помогает распознать подделку. — B) Менеджер паролей не является хорошей защитой. — C) Открытие писем от неизвестных — наоборот, увеличивает риск: письмо может содержать вредоносную ссылку или вложение. — D) Игнорирование предупреждений браузера — отключает встроенную защиту от известных фишинговых и вредоносных сайтов."
  },
  {
    "text": "Что такое брутфорс-атака?",
    "type": "choice",
    "options": ["Перебор всех возможных комбинаций пароля", "Использование украденных паролей из утечек", "Взлом через уязвимость в коде", "Социальная инженерия"],
    "correct": "A",
    "comment": "Брутфорс (brute force) — это метод, при котором злоумышленник систематически перебирает все возможные комбинации символов, пока не найдёт правильный пароль. Эффективность зависит от длины и сложности пароля: 4-значный PIN — секунды, 12-символьный пароль из букв и цифр — тысячелетия. Для ускорения используются словари (dictionary attack) — списки популярных паролей. Вариант B — это атака по словарю учётных данных, а не брутфорс."
  },
  {
    "text": "Безопасно ли использовать биометрию (отпечаток пальца) как единственный фактор аутентификации?",
    "type": "choice",
    "options": ["Да, потому что отпечаток невозможно подделать", "Нет, потому что биометрические данные нельзя изменить при утечке", "Да, потому что это удобно", "Нет, потому что отпечаток можно украсть только при физическом контакте"],
    "correct": "B",
    "comment": "Биометрия — удобный фактор, но плохой как единственный. В отличие от пароля, отпечаток пальца нельзя сменить: если он скомпрометирован (например, воссоздан по фотографии или следу), он утерян навсегда. Кроме того, биометрические данные могут быть украдены из базы данных устройства. Поэтому биометрия должна использоваться в паре с другим фактором (например, PIN-кодом) — как часть 2FA, а не как замена паролю."
  },
  {
    "text": "Что такое вредоносное ПО (malware)?",
    "type": "choice",
    "options": ["Любое программное обеспечение, установленное без ведома пользователя", "Программа, предназначенная для причинения вреда или несанкционированного доступа", "Антивирусная программа", "Операционная система"],
    "correct": "B",
    "comment": "Malware (malicious software) — это общий термин для любого ПО, созданного с вредоносными целями: кража данных (шпионское ПО), шифрование файлов (вымогатели), удалённое управление (трояны), рассылка спама (боты). Оно может быть установлено без ведома (A), но не всегда — иногда пользователь сам запускает вложение в письме. Антивирусы (C) борются с malware, а ОС (D) — платформа, на которой оно работает."
  },
  {
    "text": "Какие угрозы характерны для публичных Wi-Fi сетей?",
    "type": "choice",
    "options": ["Перехват незашифрованного трафика", "Подмена DNS-сервера", "Установка вредоносного ПО через сеть", "Автоматическое шифрование всех данных"],
    "correct": "A, B",
    "comment": "В публичных сетях злоумышленник может: — Перехватывать HTTP-трафик (A), так как он не шифруется, — Подменять DNS-ответы (B), направляя вас на фальшивые сайты. Установка ПО через сеть (C) невозможна без взаимодействия пользователя (например, загрузки файла). Шифрование (D) не происходит автоматически — только если вы используете HTTPS или VPN."
  },
  {
    "text": "Что такое вымогатель (ransomware)?",
    "type": "choice",
    "options": ["Программа, которая крадёт пароли", "Вредоносное ПО, шифрующее файлы и требующее выкуп за расшифровку", "Антивирус, блокирующий доступ к файлам", "Система резервного копирования"],
    "correct": "B",
    "comment": "Ransomware шифрует файлы пользователя (документы, фото, базы данных) и выводит сообщение с требованием оплаты (обычно в криптовалюте) за ключ расшифровки. Даже после оплаты нет гарантии, что ключ будет предоставлен. Единственная надёжная защита — регулярное резервное копирование на отключённый носитель или в облако с версионированием."
  },
  {
    "text": "Почему важно обновлять программное обеспечение?",
    "type": "choice",
    "options": ["Потому что новые версии красивее", "Потому что обновления часто содержат исправления уязвимостей", "Потому что старые версии работают быстрее", "Потому что обновления удаляют вирусы"],
    "correct": "B",
    "comment": "Разработчики регулярно выпускают патчи безопасности, закрывающие уязвимости, которые могут быть использованы злоумышленниками для удалённого выполнения кода, кражи данных или захвата системы. Неустановленные обновления — одна из главных причин взломов. Вариант D неверен: антивирусы удаляют вирусы, а не обновления (хотя некоторые обновления могут включать сигнатуры)."
  },
  {
    "text": "Что такое брандмауэр (firewall)?",
    "type": "choice",
    "options": ["Программа для шифрования данных", "Система, контролирующая входящий и исходящий сетевой трафик", "Антивирус для защиты от троянов", "Сервис для хранения паролей"],
    "correct": "B",
    "comment": "Брандмауэр анализирует сетевые пакеты и блокирует или разрешает их на основе заданных правил (IP-адрес, порт, протокол). Он защищает от несанкционированного доступа извне (например, сканирования портов) и может предотвратить утечку данных изнутри. Это не антивирус (C) и не шифрование (A)."
  },
  {
    "text": "Какие меры защищают от кейлоггеров?",
    "type": "choice",
    "options": ["Использование виртуальной клавиатуры", "Регулярное сканирование антивирусом", "Ввод паролей голосом", "Хранение паролей в браузере"],
    "correct": "A, B",
    "comment": "— A) Виртуальная клавиатура (на экране) вводит символы без нажатий физической клавиатуры, обходя программные кейлоггеры. — B) Антивирус может обнаружить и удалить известные кейлоггеры. — C) Голосовой ввод не защищает: пароль всё равно отображается на экране и может быть перехвачен скриншотом. — D) Хранение в браузере не связано с защитой от кейлоггеров — они перехватывают ввод до сохранения."
  },
  {
    "text": "Что такое уязвимость нулевого дня (zero-day)?",
    "type": "choice",
    "options": ["Уязвимость, известная разработчику уже год", "Уязвимость, для которой ещё нет патча", "Уязвимость, обнаруженная в первый день года", "Уязвимость, не представляющая угрозы"],
    "correct": "B",
    "comment": "Zero-day — это уязвимость, о которой знают злоумышленники, но не знает разработчик, поэтому нет патча для её устранения. Такие уязвимости особенно опасны, так как защититься от них сложно. После обнаружения разработчик выпускает патч, и уязвимость перестаёт быть «нулевого дня»."
  },
  {
    "text": "Безопасно ли открывать вложения в письмах от неизвестных отправителей?",
    "type": "choice",
    "options": ["Да, если письмо выглядит официально", "Нет, потому что вложение может содержать вредоносное ПО", "Да, если у вас установлен антивирус", "Нет, потому что письмо может быть отправлено повторно"],
    "correct": "B",
    "comment": "Вложения (особенно .exe, .scr, .zip, .docm) часто содержат макровирусы или трояны. Даже если письмо выглядит официально (A), оно может быть подделано (спуфинг). Антивирус (C) не даёт 100% защиты — новые угрозы могут быть неизвестны. Поэтому никогда не открывайте вложения от неизвестных."
  },
  {
    "text": "Что такое двухэтапная верификация (2SV)?",
    "type": "choice",
    "options": ["То же самое, что и двухфакторная аутентификация (2FA)", "Использование двух паролей", "Вход с подтверждением по email и SMS", "Шифрование данных двумя алгоритмами"],
    "correct": "C",
    "comment": "2SV — это частный случай 2FA, где оба фактора относятся к категории «владение»: например, SMS-код (телефон) и email-код (почтовый ящик). Это менее безопасно, чем настоящая 2FA (например, пароль + аппаратный токен), так как и телефон, и почта могут быть скомпрометированы (SIM-swap, взлом email). Но лучше, чем ничего."
  },
  {
    "text": "Какие данные наиболее опасно хранить в открытом виде на компьютере?",
    "type": "choice",
    "options": ["Фотографии", "Документы", "Файлы с паролями и финансовыми данными", "Музыка"],
    "correct": "C",
    "comment": "Пароли, банковские реквизиты, персональные документы — это чувствительные данные, которые могут быть использованы для кражи личности, финансового мошенничества или шантажа. Они должны храниться только в зашифрованном виде (менеджер паролей, зашифрованный архив). Фото, документы, музыка — менее критичны, хотя тоже могут быть конфиденциальными."
  },
  {
    "text": "Что такое атака типа «отказ в обслуживании» (DoS)?",
    "type": "choice",
    "options": ["Кража данных из базы данных", "Перегрузка системы запросами для нарушения её работы", "Установка шпионского ПО", "Фишинговая атака"],
    "correct": "B",
    "comment": "DoS (Denial of Service) — это атака, целью которой является сделать сервис недоступным для легитимных пользователей. Это достигается затоплением сервера запросами (например, SYN-flood), исчерпывающими его ресурсы (CPU, память, пропускную способность). DDoS — распределённая версия, с тысячами заражённых устройств (ботнет)."
  },
  {
    "text": "Какие действия снижают риск взлома аккаунта?",
    "type": "choice",
    "options": ["Использование уникального сложного пароля", "Включение двухфакторной аутентификации", "Регулярная смена пароля без причины", "Использование одного пароля для всех сервисов"],
    "correct": "A, B",
    "comment": "— A) Уникальный сложный пароль предотвращает подбор и повторное использование. — B) 2FA добавляет второй барьер даже при утечке пароля. — C) Регулярная смена не рекомендуется NIST, если нет подозрений на компрометацию. — D) Один пароль — главная ошибка, ведущая к каскадному взлому."
  },
  {
    "text": "Что такое SSL/TLS?",
    "type": "choice",
    "options": ["Протокол для шифрования сетевого трафика", "Антивирусная программа", "Система резервного копирования", "Метод взлома паролей"],
    "correct": "A",
    "comment": "SSL/TLS — это криптографические протоколы, обеспечивающие конфиденциальность и целостность данных при передаче по сети. Они используются в HTTPS, SMTPS, IMAPS и других защищённых протоколах. Замок в адресной строке браузера означает, что соединение защищено TLS."
  },
  {
    "text": "Почему важно использовать HTTPS вместо HTTP?",
    "type": "choice",
    "options": ["Потому что HTTPS быстрее", "Потому что HTTPS шифрует данные между браузером и сервером", "Потому что HTTP устарел", "Потому что HTTPS бесплатен"],
    "correct": "B",
    "comment": "HTTP передаёт данные в открытом виде, что позволяет перехватывать логины, пароли, сообщения. HTTPS = HTTP + TLS, то есть все данные шифруются, защищая от MITM и перехвата в публичных сетях. Скорость (A) почти одинакова, HTTP не устарел (C), а HTTPS бесплатен благодаря Let's Encrypt (D), но это не основная причина."
  },
  {
    "text": "Что такое SIM-swap атака?",
    "type": "choice",
    "options": ["Взлом SIM-карты с помощью радиосигналов", "Перенос номера телефона на SIM-карту злоумышленника", "Кража данных с SIM-карты", "Блокировка SIM-карты оператором"],
    "correct": "B",
    "comment": "При SIM-swap злоумышленник обманом или коррупцией заставляет оператора связи перенести ваш номер на свою SIM-карту. После этого он получает все SMS и звонки, включая коды 2FA, и может взломать ваши аккаунты. Защита: использовать аппаратные токены или приложения для 2FA вместо SMS."
  },
  {
    "text": "Какие угрозы связаны с использованием SMS для двухфакторной аутентификации?",
    "type": "choice",
    "options": ["Уязвимость к SIM-swap атакам", "Перехват SMS через уязвимости в сети (SS7)", "SMS могут быть прочитаны на заблокированном экране", "SMS шифруются энд-ту-энд"],
    "correct": "A, B, C",
    "comment": "— A) SIM-swap позволяет перехватить все SMS. — B) Уязвимости SS7 в телекоммуникационных сетях позволяют перехватывать SMS удалённо. — C) Уведомления SMS часто отображаются на заблокированном экране, что позволяет прочитать код прохожему. — D) SMS не шифруются — это открытый протокол."
  },
  {
    "text": "Что такое фишинг через SMS (смишинг)?",
    "type": "choice",
    "options": ["Рассылка спама по SMS", "Отправка SMS с вредоносной ссылкой или запросом данных", "Взлом телефона через SMS", "Блокировка SMS-сообщений"],
    "correct": "B",
    "comment": "Смишинг (smishing = SMS + phishing) — это фишинг через SMS. Сообщение имитирует банк, службу доставки или госорган, содержит ссылку на поддельный сайт или просит ответить личными данными. Пример: «Ваш пакет задержан. Подтвердите данные: [ссылка]»."
  },
  {
    "text": "Безопасно ли использовать общие компьютеры (в библиотеке, интернет-кафе) для входа в личные аккаунты?",
    "type": "choice",
    "options": ["Да, если очистить историю браузера после выхода", "Нет, потому что на компьютере может быть кейлоггер", "Да, если использовать инкогнито-режим", "Нет, потому что интернет в кафе медленный"],
    "correct": "B",
    "comment": "Общие компьютеры могут содержать аппаратные или программные кейлоггеры, которые записывают все нажатия клавиш, включая пароли. Инкогнито-режим (C) и очистка истории (A) не защищают от этого. Лучше вообще не входить в личные аккаунты с общих устройств."
  },
  {
    "text": "Что такое атака на слабый пароль?",
    "type": "choice",
    "options": ["Использование словаря популярных паролей для подбора", "Взлом через уязвимость в веб-сервере", "Социальная инженерия", "Перехват трафика"],
    "correct": "A",
    "comment": "Эта атака использует списки самых популярных паролей (123456, password, qwerty), которые подбираются за секунды. Она эффективна против пользователей, которые не используют сложные или уникальные пароли."
  },
  {
    "text": "Какие меры защищают от атак на слабые пароли?",
    "type": "choice",
    "options": ["Использование длинных паролей из случайных символов", "Использование менеджера паролей", "Использование даты рождения как пароля", "Использование одного пароля для всех аккаунтов"],
    "correct": "A, B",
    "comment": "— A) Случайные длинные пароли устойчивы к словарным атакам. — B) Менеджер паролей генерирует и хранит такие пароли. — C) Дата рождения — слабый пароль, легко угадываемый. — D) Один пароль — катастрофа при утечке."
  },
  {
    "text": "Что такое атака «повторного воспроизведения» (replay attack)?",
    "type": "choice",
    "options": ["Перехват и повторная отправка действительного сетевого пакета", "Повторная отправка пароля при ошибке", "Воспроизведение видео с вредоносным кодом", "Повторный запуск вируса"],
    "correct": "A",
    "comment": "При replay attack злоумышленник перехватывает, например, токен аутентификации или транзакцию и повторно отправляет его серверу, чтобы выполнить действие от имени жертвы. Защита: использование одноразовых токенов, временных меток и криптографических подписей."
  },
  {
    "text": "Почему важно использовать уникальные email-адреса для критических аккаунтов (банк, почта)?",
    "type": "choice",
    "options": ["Потому что это красиво", "Потому что это затрудняет связывание аккаунтов при утечке", "Потому что email влияет на скорость работы", "Потому что банки требуют отдельный email"],
    "correct": "B",
    "comment": "Если вы используете один email для всех сервисов, утечка базы данных одного сайта позволяет злоумышленнику найти все ваши аккаунты. Уникальные email (например, через алиасы в ProtonMail или Firefox Relay) изолируют аккаунты друг от друга."
  },
  {
    "text": "Что такое фишинг через звонки (вishing)?",
    "type": "choice",
    "options": ["Рассылка спама по телефону", "Звонок от имени доверенной организации с запросом данных", "Взлом телефона через звонок", "Блокировка звонков"],
    "correct": "B",
    "comment": "Вishing (voice phishing) — это звонок от «банка», «техподдержки» или «налоговой» с требованием назвать пароль, код из SMS или установить «программу для защиты». Настоящие организации никогда не запрашивают конфиденциальные данные по телефону."
  },
  {
    "text": "Какие действия следует предпринять при подозрении на компрометацию аккаунта?",
    "type": "choice",
    "options": ["Немедленно сменить пароль", "Включить двухфакторную аутентификацию", "Проигнорировать, если нет явных признаков", "Проверить активность в журнале входов"],
    "correct": "A, B, D",
    "comment": "— A) Смена пароля — первое действие. — B) Включение 2FA — предотвращает повторный взлом. — D) Журнал входов покажет подозрительные сессии. — C) Игнорирование — ошибка, так как злоумышленник может ждать подходящего момента."
  },
  {
    "text": "Что такое утечка данных (data breach)?",
    "type": "choice",
    "options": ["Случайное удаление файлов", "Несанкционированный доступ к конфиденциальной информации", "Потеря USB-накопителя", "Сбой жёсткого диска"],
    "correct": "B",
    "comment": "Data breach — это инцидент, при котором конфиденциальные данные (пароли, email, номера карт) становятся доступны неавторизованным лицам, обычно из-за взлома сервера или утечки базы данных. Это не обязательно вина пользователя, но требует реакции (смена паролей)."
  },
  {
    "text": "Как проверить, был ли ваш email скомпрометирован в утечках?",
    "type": "choice",
    "options": ["Через сервис Have I Been Pwned", "Через Google Search", "Через антивирус", "Через настройки браузера"],
    "correct": "A",
    "comment": "Have I Been Pwned (haveibeenpwned.com) — сервис от специалиста по безопасности Троя Ханта, который позволяет проверить email или телефон по базе известных утечек. Это надёжный и бесплатный способ узнать о компрометации."
  },
  {
    "text": "Что такое атака «подмена сессии» (session hijacking)?",
    "type": "choice",
    "options": ["Украсть cookie браузера для входа в аккаунт без пароля", "Угадать пароль методом перебора", "Взломать сессию видеосвязи", "Перехватить сессию SSH"],
    "correct": "A",
    "comment": "После входа в аккаунт браузер получает cookie сессии, который автоматически отправляется при каждом запросе. Если злоумышленник украдёт этот cookie (например, через XSS-уязвимость или перехват в незащищённой сети), он сможет войти в аккаунт без пароля. Защита: использование HTTPS, флагов HttpOnly и Secure для cookie."
  },
  {
    "text": "Почему важно использовать уникальные пароли для email и других аккаунтов?",
    "type": "choice",
    "options": ["Потому что email — это основной аккаунт для восстановления", "Потому что email требует более сложного пароля", "Потому что другие аккаунты менее важны", "Потому что пароли для email должны быть короче"],
    "correct": "A",
    "comment": "Почта используется для восстановления доступа ко всем остальным аккаунтам («Забыли пароль?» → код на email). Если пароль от почты скомпрометирован, злоумышленник может восстановить доступ ко всем вашим сервисам. Поэтому пароль от email должен быть самым надёжным и уникальным."
  },
  {
    "text": "Что такое XSS-уязвимость?",
    "type": "choice",
    "options": ["Уязвимость, позволяющая выполнять произвольный JavaScript в браузере жертвы", "Уязвимость в операционной системе", "Вирус, поражающий браузер", "Ошибка в настройке брандмауэра"],
    "correct": "A",
    "comment": "XSS (Cross-Site Scripting) возникает, когда сайт некорректно обрабатывает пользовательский ввод и вставляет его в HTML без экранирования. Злоумышленник может внедрить скрипт, который украдёт cookie сессии, перенаправит на фишинговый сайт или выполнит действия от имени жертвы."
  },
  {
    "text": "Какие меры защищают от XSS?",
    "type": "choice",
    "options": ["Экранирование пользовательского ввода на стороне сервера", "Использование Content Security Policy (CSP)", "Отключение JavaScript в браузере", "Использование HTTP вместо HTTPS"],
    "correct": "A, B",
    "comment": "— A) Экранирование (например, замена < на &lt;) предотвращает выполнение скриптов. — B) CSP — HTTP-заголовок, ограничивающий источники, из которых можно загружать скрипты. — C) Отключение JS защищает, но делает большинство сайтов неработоспособными — непрактично. — D) HTTP снижает безопасность, так как CSP и другие механизмы требуют HTTPS."
  },
  {
    "text": "Что такое SQL-инъекция?",
    "type": "choice",
    "options": ["Вставка вредоносного SQL-кода в форму сайта для доступа к базе данных", "Вирус, заражающий базы данных", "Ошибка в написании SQL-запроса", "Шифрование базы данных"],
    "correct": "A",
    "comment": "SQL-инъекция происходит, когда приложение некорректно вставляет пользовательский ввод в SQL-запрос. Например, в поле логина вводится `' OR '1'='1`, что превращает запрос в `SELECT * FROM users WHERE login = '' OR '1'='1' --`, давая доступ без пароля. Защита: параметризованные запросы."
  },
  {
    "text": "Какие действия защищают от SQL-инъекций?",
    "type": "choice",
    "options": ["Использование параметризованных запросов", "Экранирование спецсимволов во вводе", "Ограничение прав доступа базы данных для веб-приложения", "Использование простых паролей для базы данных"],
    "correct": "A, B, C",
    "comment": "— A) Параметризованные запросы — лучшая защита, так как данные и код разделены. — B) Экранирование — дополнительная мера. — C) Минимальные права (например, только SELECT для публичных запросов) ограничивают ущерб. — D) Простые пароли — угроза, а не защита."
  },
  {
    "text": "Что такое принцип минимальных привилегий?",
    "type": "choice",
    "options": ["Каждый пользователь и процесс должны иметь только необходимые права", "Все пользователи должны иметь одинаковые права", "Администратор должен иметь все права", "Права должны быть максимальными для удобства"],
    "correct": "A",
    "comment": "Этот принцип гласит, что субъект (пользователь, программа) должен иметь только те привилегии, которые необходимы для выполнения его задачи. Это минимизирует ущерб при компрометации: если вредоносное ПО захватит учётную запись с ограниченными правами, оно не сможет повредить всей системе."
  },
  {
    "text": "Почему важно делать резервные копии данных?",
    "type": "choice",
    "options": ["Потому что это бесплатно", "Потому что это защищает от потери данных при атаке вымогателей или сбое оборудования", "Потому что это ускоряет работу компьютера", "Потому что это требование закона"],
    "correct": "B",
    "comment": "Резервные копии — единственная надёжная защита от потери данных из-за вымогателей, сбоев диска, случайного удаления или стихийных бедствий. Их нужно хранить отдельно от основной системы (внешний диск, облако) и регулярно проверять восстановление."
  },
  {
    "text": "Что такое безопасность по умолчанию (secure by default)?",
    "type": "choice",
    "options": ["Система поставляется с максимально открытыми настройками для удобства", "Система поставляется с максимально закрытыми настройками для безопасности", "Пользователь сам настраивает безопасность при установке", "Безопасность включается только после покупки лицензии"],
    "correct": "B",
    "comment": "Secure by default означает, что продукт (ОС, ПО, устройство) из коробки настроен максимально безопасно: отключены ненужные службы, включён брандмауэр, требуется сильный пароль. Это защищает неподготовленных пользователей. Вариант A — «удобно, но небезопасно», что часто приводит к взломам."
  }
],

  "type_13": [
  {
    "text": "Определите парадигму по фрагменту кода:\nint factorial(int n) {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);\n}",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "A",
    "comment": "Код написан на C и использует процедуру с рекурсией, но без неизменяемых данных или функций высшего порядка. Это классический пример процедурного программирования — подмножество императивной парадигмы. Вариант D тоже верен в широком смысле, но в учебных тестах такой код чаще относят к процедурной как более точной категории."
  },
  {
    "text": "Какая парадигма основана на передаче сообщений между объектами, инкапсуляции данных и полиморфизме?",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "C",
    "comment": "Объектно-ориентированное программирование (ООП) строится на четырёх столпах: абстракция, инкапсуляция, наследование, полиморфизм. Объекты взаимодействуют через передачу сообщений (вызов методов). Функциональная парадигма (A) избегает состояния и объектов, логическая (B) основана на фактах и правилах (Prolog), процедурная (D) — на вызовах функций без объектов."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nclass BankAccount:\n    def __init__(self, balance):\n        self.__balance = balance  # Инкапсуляция\n    \n    def deposit(self, amount):\n        self.__balance += amount\n    \n    def get_balance(self):\n        return self.__balance",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "B",
    "comment": "Код определяет класс с приватным состоянием (__balance) и методами, управляющими этим состоянием. Это классические признаки ООП: инкапсуляция (скрытие данных), объекты (экземпляры класса), передача сообщений (вызов deposit). Нет функций высшего порядка — это не функциональная парадигма."
  },
  {
    "text": "Какая парадigmа характеризуется отсутствием побочных эффектов и использованием неизменяемых данных?",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "Функциональное программирование требует, чтобы функции были чистыми: одинаковые аргументы всегда дают одинаковый результат, и нет изменения глобального состояния. Данные неизменяемы — вместо модификации создаются новые структуры. Пример: в Haskell или чистом Python с map, filter, reduce. Императивные парадигмы (A, D) активно используют состояние и побочные эффекты, ООП (B) — инкапсулированное состояние."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Логическая"],
    "correct": "C",
    "comment": "Код написан на Haskell — чисто функциональном языке. Здесь нет переменных, нет циклов, нет состояния — только рекурсивное определение функции через сопоставление с образцом. Это чистая функциональная парадигма. В процедурных языках (A) такая рекурсия возможна, но с побочными эффектами и изменяемыми данными."
  },
  {
    "text": "Какая парадигма использует факты и правила для вывода новых знаний?",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "B",
    "comment": "Логическое программирование (например, Prolog) описывает задачу через факты (parent(tom, bob).) и правила (grandparent(X, Z) :- parent(X, Y), parent(Y, Z).), а система сама ищет решение. Это декларативный подход, в отличие от императивных парадигм, где описывается последовательность шагов."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\npublic class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\npublic class Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Bark\");\n    }\n}",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "B",
    "comment": "Код демонстрирует наследование (Dog extends Animal) и полиморфизм (переопределение метода makeSound). Это ключевые механизмы ООП. Нет функций высшего порядка — не функциональная, нет чистых функций — не функциональная, нет простых процедур без объектов — не процедурная."
  },
  {
    "text": "Какая парадигма предполагает, что программа состоит из последовательности команд, изменяющих состояние программы?",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Императивная"],
    "correct": "D",
    "comment": "Императивное программирование — это классический подход, где программа — это список инструкций, которые изменяют состояние (значения переменных, памяти). Примеры: C, Pascal, BASIC. Процедурное (подмножество императивного) и ООП (расширение императивного) тоже изменяют состояние, но императивная — наиболее общая категория для такого описания."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nnumbers = [1, 2, 3, 4]\nsquared = list(map(lambda x: x ** 2, numbers))",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "Используется функция высшего порядка map и лямбда-выражение (анонимная функция). Нет явных циклов, состояние не изменяется (создаётся новый список). Это признаки функционального стиля даже в мультипарадигменном языке Python. Процедурный аналог использовал бы цикл for."
  },
  {
    "text": "Какая парадигма избегает использования циклов и предпочитает рекурсию?",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "В функциональных языках (Haskell, Lisp) циклы невозможны, так как нет изменяемого состояния. Повторение достигается через рекурсию. В императивных языках (C, Java) циклы — основной инструмент, рекурсия используется редко из-за ограничений стека."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\n#include <stdio.h>\nvoid print_hello() {\n    printf(\"Hello, World!\\n\");\n}\nint main() {\n    print_hello();\n    return 0;\n}",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Логическая"],
    "correct": "A",
    "comment": "Программа состоит из процедур (print_hello, main), вызываемых последовательно. Нет объектов, классов, функций высшего порядка или логических правил. Это классический пример процедурного программирования на C."
  },
  {
    "text": "Какие утверждения верны для функциональной парадигмы?",
    "type": "choice",
    "options": ["Функции являются объектами первого класса", "Используются замыкания", "Данные неизменяемы", "Программа состоит из объектов и их взаимодействия"],
    "correct": "A, B, C",
    "comment": "В функциональном программировании функции — объекты первого класса (их можно передавать как аргументы, возвращать из функций), используются замыкания (функции, захватывающие окружение), и данные неизменяемы. Вариант D описывает ООП."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nparent(tom, bob).\nparent(bob, liz).\ngrandparent(X, Z) :- parent(X, Y), parent(Y, Z).",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "B",
    "comment": "Код написан на Prolog — языке логического программирования. Описаны факты (parent/2) и правило (grandparent/2). Запрос ?- grandparent(tom, liz). вернёт true. Это декларативный стиль: описывается «что», а не «как»."
  },
  {
    "text": "Какая парадигма наиболее подходит для моделирования реальных объектов и их взаимодействий?",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "C",
    "comment": "ООП позволяет создавать классы, соответствующие реальным сущностям («Автомобиль», «Банковский счёт»), с их свойствами (поля) и поведением (методы). Это делает код интуитивно понятным и масштабируемым для сложных систем."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nconst add = (a) => (b) => a + b;\nconst add5 = add(5);\nconsole.log(add5(3)); // 8",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "Код демонстрирует каррирование — технику функционального программирования, где функция принимает аргументы по одному и возвращает новую функцию. Используются стрелочные функции и замыкания. Нет изменения состояния — чисто функциональный стиль."
  },
  {
    "text": "Что такое «чистая функция»?",
    "type": "choice",
    "options": ["Функция, которая не использует глобальные переменные", "Функция, которая всегда возвращает одинаковый результат для одинаковых аргументов и не имеет побочных эффектов", "Функция, написанная на функциональном языке", "Функция, которая не вызывает другие функции"],
    "correct": "B",
    "comment": "Чистая функция — основа функционального программирования. Она зависит только от своих аргументов и ничего не изменяет во внешнем мире (не пишет в файл, не меняет глобальные переменные, не выводит в консоль). Это делает её предсказуемой и легко тестируемой."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]  # Изменение состояния\n    return arr",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Логическая"],
    "correct": "A",
    "comment": "Код использует вложенные циклы и изменяет входной массив на месте — это классический императивный/процедурный подход. Функциональная реализация использовала бы рекурсию и создавала бы новый отсортированный список без изменения исходного."
  },
  {
    "text": "Какая парадигма использует понятия «факт», «правило» и «запрос»?",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "B",
    "comment": "Эти термины специфичны для логического программирования (Prolog). Факты — утверждения об истине, правила — условия вывода, запросы — вопросы к системе."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nval numbers = List(1, 2, 3, 4)\nval doubled = numbers.map(_ * 2)",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "Scala — мультипарадигменный язык, но этот код использует метод map на неизменяемом списке, что является функциональным стилем. Создаётся новый список doubled, исходный не изменяется."
  },
  {
    "text": "Какая парадигма характеризуется использованием классов и наследования?",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "C",
    "comment": "Классы и наследование — фундаментальные концепции ООП. Они позволяют создавать иерархии типов и повторно использовать код. Функциональные языки могут эмулировать наследование через композицию, но это не основной механизм."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nint sum = 0;\nfor (int i = 0; i < 10; i++) {\n    sum += i;  // Изменение состояния\n}",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Логическая"],
    "correct": "A",
    "comment": "Цикл for и изменение переменной sum — это императивный/процедурный стиль. Функциональный эквивалент использовал бы fold или рекурсию без мутации."
  },
  {
    "text": "Какие языки являются функциональными?",
    "type": "choice",
    "options": ["Haskell", "Lisp", "Java", "C++"],
    "correct": "A, B",
    "comment": "Haskell — чисто функциональный язык. Lisp — один из первых функциональных языков. Java и C++ — императивные/ООП языки с некоторыми функциональными возможностями (лямбды), но не являются функциональными."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(1, 2)",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "namedtuple создаёт неизменяемый кортеж с именованными полями — это функциональный подход к структурам данных. В ООП использовался бы класс с возможностью изменения состояния."
  },
  {
    "text": "Что такое «побочный эффект» в контексте функционального программирования?",
    "type": "choice",
    "options": ["Ошибка в программе", "Любое взаимодействие функции с внешним миром (изменение переменной, ввод-вывод)", "Использование рекурсии", "Вызов другой функции"],
    "correct": "B",
    "comment": "Побочный эффект — это любое действие функции, кроме возврата значения: изменение глобальной переменной, запись в файл, вывод на экран, генерация случайного числа. Чистые функции их избегают."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4);\nList<Integer> squared = numbers.stream()\n                                .map(x -> x * x)\n                                .collect(Collectors.toList());",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "Использование Stream API с map — это функциональный стиль в Java. Поток обрабатывается как единое целое, без явных циклов и мутации."
  },
  {
    "text": "Какая парадигма наиболее эффективна для параллельных вычислений?",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "Отсутствие состояния и побочных эффектов в функциональном программировании позволяет безопасно выполнять функции параллельно, так как они не конфликтуют за ресурсы. В императивных парадигмах требуется синхронизация доступа к общему состоянию."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\ndef greet(name):\n    return f\"Hello, {name}!\"\nprint(greet(\"Alice\"))",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "A",
    "comment": "Простая функция без состояния, но в контексте Python это считается процедурным стилем, так как нет использования функциональных конструкций (лямбды, map, reduce). Это не чисто функциональный код, так как использует строковый формат, но и не ООП."
  },
  {
    "text": "Какая парадигма использует понятие «состояние объекта»?",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "C",
    "comment": "В ООП каждый объект имеет внутреннее состояние (поля), которое может изменяться через методы. Функциональная парадигма избегает состояния, логическая оперирует фактами, процедурная — глобальными переменными."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\n-module(math).\n-export([factorial/1]).\n\nfactorial(0) -> 1;\nfactorial(N) -> N * factorial(N - 1).",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "A",
    "comment": "Erlang — функциональный язык с акцентом на паралелизм. Код использует сопоставление с образцом и рекурсию без состояния — чисто функциональный стиль."
  },
  {
    "text": "Что такое «замыкание» (closure)?",
    "type": "choice",
    "options": ["Функция, которая закрывает файл", "Функция, которая захватывает переменные из своего окружения", "Метод класса, скрывающий данные", "Блок кода в фигурных скобках"],
    "correct": "B",
    "comment": "Замыкание — это функция, которая запоминает своё лексическое окружение даже после завершения внешней функции. Это ключевой механизм в функциональном программировании для создания функций с «памятью»."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nvar numbers = new List<int> {1, 2, 3, 4};\nvar squared = numbers.Select(x => x * x).ToList();",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "Использование LINQ с Select — это функциональный стиль в C#. Создаётся новый список без мутации исходного."
  },
  {
    "text": "Какая парадигма предполагает, что программа — это описание логических отношений?",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "B",
    "comment": "В логическом программировании программа — это набор логических утверждений, а выполнение — процесс логического вывода. Это радикально отличается от императивных подходов."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nconfig = {\"host\": \"localhost\", \"port\": 8080}\ndef connect(cfg):\n    print(f\"Connecting to {cfg['host']}:{cfg['port']}\")\nconnect(config)",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "A",
    "comment": "Код использует функцию и словарь для передачи данных — это процедурный стиль. Нет классов (не ООП), нет функций высшего порядка (не функциональный)."
  },
  {
    "text": "Какие признаки характерны для объектно-ориентированной парадигмы?",
    "type": "choice",
    "options": ["Инкапсуляция", "Наследование", "Полиморфизм", "Неизменяемость данных"],
    "correct": "A, B, C",
    "comment": "Это три (или четыре, с абстракцией) кита ООП. Неизменяемость (D) — признак функциональной парадигмы."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nlet rec factorial n =\n    if n <= 1 then 1 else n * factorial (n - 1)",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "A",
    "comment": "F# — функциональный язык от Microsoft. Код использует рекурсию и отсутствие мутации — чисто функциональный стиль."
  },
  {
    "text": "Что такое «императивное программирование»?",
    "type": "choice",
    "options": ["Программирование с использованием чистых функций", "Программирование, основанное на описании шагов для изменения состояния", "Программирование с использованием объектов", "Программирование на основе логических правил"],
    "correct": "B",
    "comment": "Императивное программирование — это описание последовательности команд, которые изменяют состояние программы. Это противоположность декларативным парадигмам (функциональной, логической), где описывается «что», а не «как»."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\npackage main\nimport \"fmt\"\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "A",
    "comment": "Go поддерживает процедурный стиль через функции. Хотя он имеет структуры и методы, полноценного ООП (наследования) нет. Этот код — простой вызов функции, что характерно для процедурного программирования."
  },
  {
    "text": "Какая парадигма использует «функции высшего порядка»?",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "Функции высшего порядка — это функции, которые принимают другие функции в качестве аргументов или возвращают их. Это фундаментальный механизм функционального программирования (например, map, filter, reduce)."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nfn main() {\n    let numbers = vec![1, 2, 3, 4];\n    let doubled: Vec<i32> = numbers.iter().map(|x| x * 2).collect();\n    println!(\"{:?}\", doubled);\n}",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "Rust поддерживает функциональный стиль через итераторы и map. Код не изменяет исходный вектор, а создаёт новый — это функциональный подход."
  },
  {
    "text": "Что такое «декларативное программирование»?",
    "type": "choice",
    "options": ["Программирование, описывающее последовательность шагов", "Программирование, описывающее, что должно быть достигнуто, а не как", "Программирование с использованием объектов", "Программирование на ассемблере"],
    "correct": "B",
    "comment": "Декларативные парадигмы (функциональная, логическая) фокусируются на описании желаемого результата, а не алгоритма его достижения. Императивное программирование — противоположность."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nlet numbers = [1, 2, 3, 4]\nlet evens = numbers.filter { $0 % 2 == 0 }",
    "type": "choice",
    "options": ["Процedурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "Swift поддерживает функциональный стиль. filter с замыканием — это функциональный подход, создающий новый массив без мутации исходного."
  },
  {
    "text": "Какая парадигма наиболее подходит для математических вычислений и символьной обработки?",
    "type": "choice",
    "options": ["Процедурная", "Логическая", "Функциональная", "Объектно-ориентированная"],
    "correct": "C",
    "comment": "Функциональные языки близки к математике: функции, рекурсия, неизменяемость. Они широко используются в научных вычислениях, компиляторах и AI."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nfun main() {\n    val numbers = listOf(1, 2, 3, 4)\n    val sum = numbers.sum()\n    println(sum)\n}",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "Kotlin поддерживает функциональный стиль. sum() — это метод, работающий с неизменяемым списком, что характерно для функционального подхода."
  },
  {
    "text": "Что такое «полиморфизм» в ООП?",
    "type": "choice",
    "options": ["Возможность функции работать с разными типами данных", "Скрытие деталей реализации", "Создание нового класса на основе существующего", "Использование чистых функций"],
    "correct": "A",
    "comment": "Полиморфизм позволяет использовать один интерфейс для разных типов. Например, метод draw() может вызываться для объектов Circle и Square, и каждый реализует его по-своему."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\ndefmodule Math do\n  def factorial(0), do: 1\n  def factorial(n), do: n * factorial(n - 1)\nend",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "A",
    "comment": "Elixir — функциональный язык на виртуальной машине Erlang. Код использует сопоставление с образцом и рекурсию — чисто функциональный стиль."
  },
  {
    "text": "Какая парадигма использует «передачу сообщений» как основной способ взаимодействия?",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "C",
    "comment": "В ООП объекты взаимодействуют, посылая сообщения друг другу (вызывая методы). Это ключевой принцип, отличающий ООП от других парадигм."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\nnumbers <- c(1, 2, 3, 4)\nsquared <- numbers^2",
    "type": "choice",
    "options": ["Процедурная", "Объектно-ориентированная", "Функциональная", "Императивная"],
    "correct": "C",
    "comment": "R поддерживает векторизированные операции, которые применяются ко всем элементам сразу без циклов. Это функциональный стиль, так как создаётся новый вектор без мутации."
  },
  {
    "text": "Что такое «инкапсуляция» в ООП?",
    "type": "choice",
    "options": ["Скрытие внутренних деталей объекта и предоставление интерфейса", "Создание нового класса на основе существующего", "Использование функций высшего порядка", "Отсутствие побочных эффектов"],
    "correct": "A",
    "comment": "Инкапсуляция — это механизм, который скрывает внутреннее состояние объекта и позволяет взаимодействовать с ним только через публичные методы. Это повышает безопасность и упрощает поддержку."
  },
  {
    "text": "Определите парадигму по фрагменту кода:\n(defn factorial [n]\n  (if (<= n 1)\n    1\n    (* n (factorial (- n 1)))))",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "A",
    "comment": "Clojure — диалект Lisp, функциональный язык. Код использует рекурсию и отсутствие мутации — чисто функциональный стиль."
  },
  {
    "text": "Какая парадигма наиболее подходит для разработки крупных корпоративных приложений с сложной доменной моделью?",
    "type": "choice",
    "options": ["Функциональная", "Логическая", "Объектно-ориентированная", "Процедурная"],
    "correct": "C",
    "comment": "ООП позволяет моделировать бизнес-процессы через классы и объекты, что делает код понятным для аналитиков и разработчиков. Инкапсуляция, наследование и полиморфизм помогают управлять сложностью в больших проектах."
  }
]
}
